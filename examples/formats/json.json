{
  "timestamp": "2025-01-14 23:07:50",
  "tree": "└── amalgo/\n    ├── main.go\n    ├── main_test.go\n    ├── internal/\n    │   ├── output.go\n    │   ├── output_json.go\n    │   ├── traverse.go\n    │   ├── traverse_test.go\n    │   ├── utils.go\n    │   └── parser/\n    │       ├── golang.go\n    │       └── parser.go\n    ├── pkg/\n    │   └── filter/\n    │       ├── filter.go\n    │       └── filter_test.go\n    └── testdir/\n        ├── file1.go\n        └── sub/\n            └── file2.go\n",
  "files": [
    {
      "path": "amalgo/internal/output.go",
      "content": "package internal\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/Broderick-Westrope/amalgo/internal/parser\"\n)\n\ntype OutputFormat string\n\nconst (\n\tOutputFormatDefault = \"default\"\n\tOutputFormatJSON    = \"json\"\n)\n\n// Options configures the output generation\ntype OutputOptions struct {\n\tNoTree     bool\n\tNoDump     bool\n\tOutline    bool\n\tSkipBinary bool\n\tFormat     OutputFormat\n}\n\n// GenerateOutput creates the complete output string\nfunc GenerateOutput(paths []PathInfo, registry *parser.Registry, opts OutputOptions) (string, error) {\n\tif opts.Format == OutputFormatJSON {\n\t\treturn generateOutputJSON(paths, registry, opts)\n\t}\n\n\toutput := fmt.Sprintf(\"## Generated with Amalgo at: %s\\n\\n\", FormatTimestamp())\n\n\tif !opts.NoTree {\n\t\toutput += fmt.Sprintf(\"## File Tree\\n\\n%s\\n\", GenerateTree(paths))\n\t}\n\n\tif opts.Outline {\n\t\toutlines, err := generateOutlines(paths, registry)\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"generating outlines: %w\", err)\n\t\t}\n\t\toutput += outlines\n\t}\n\n\tif !opts.NoDump {\n\t\tfilesDump, err := dumpFiles(paths, opts.SkipBinary)\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"dumping files: %w\", err)\n\t\t}\n\t\toutput += filesDump\n\t}\n\treturn output, nil\n}\n\nfunc generateOutlines(paths []PathInfo, registry *parser.Registry) (string, error) {\n\toutput := \"## Language-Specific Outlines\\n\\n\"\n\n\tvar temp string\n\tvar err error\n\tfor _, path := range paths {\n\t\tif path.IsDir {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Skip if no parser available for this file type\n\t\tif !registry.IsSupported(path.Path) {\n\t\t\tcontinue\n\t\t}\n\n\t\ttemp, err = processFileOutline(path.Path, registry)\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"processing outline for %q: %w\", path.Path, err)\n\t\t}\n\t\toutput += fmt.Sprintf(\"### File: %s\\n\\n%s\\n\", path.RelativePath, temp)\n\t}\n\treturn output, nil\n}\n\nfunc processFileOutline(filePath string, registry *parser.Registry) (string, error) {\n\tcontent, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"reading file: %w\", err)\n\t}\n\n\tparser := registry.GetParser(filePath)\n\tif parser == nil {\n\t\treturn \"\", fmt.Errorf(\"no parser found for %q\", filePath)\n\t}\n\n\toutline, err := parser.Parse(content, filePath)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"parsing file %q: %w\", filePath, err)\n\t}\n\n\tif len(outline.Errors) \u003e 0 {\n\t\tvar errMsgs []string\n\t\tfor _, err := range outline.Errors {\n\t\t\terrMsgs = append(errMsgs, err.Error())\n\t\t}\n\t\treturn fmt.Sprintf(\"Parsing errors:\\n%s\\n\", strings.Join(errMsgs, \"\\n\")), nil\n\t}\n\n\tresult, err := writeSymbols(outline.Symbols, 0)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"writing symbols: %w\", err)\n\t}\n\treturn result, nil\n}\n\nfunc writeSymbols(symbols []*parser.Symbol, depth int) (string, error) {\n\tindent := strings.Repeat(\"  \", depth)\n\tvar output string\n\tfor _, symbol := range symbols {\n\t\t// Write symbol header\n\t\toutput += fmt.Sprintf(\"%s%s: %s\", indent, strings.ToUpper(symbol.Type), symbol.Name)\n\t\tif symbol.Signature != \"\" {\n\t\t\toutput += fmt.Sprintf(\" (%s)\", symbol.Signature)\n\t\t}\n\t\toutput += \"\\n\"\n\n\t\t// Write decorators if present\n\t\tif len(symbol.Decorators) \u003e 0 {\n\t\t\toutput += fmt.Sprintf(\"%s  Decorators: %s\\n\", indent, strings.Join(symbol.Decorators, \", \"))\n\t\t}\n\n\t\t// Write docstring if present\n\t\tif symbol.Docstring != \"\" {\n\t\t\tdocLines := strings.Split(strings.TrimSpace(symbol.Docstring), \"\\n\")\n\t\t\toutput += fmt.Sprintf(\"%s  Documentation:\\n\", indent)\n\t\t\tfor _, line := range docLines {\n\t\t\t\toutput += fmt.Sprintf(\"%s    %s\\n\", indent, line)\n\t\t\t}\n\t\t}\n\n\t\t// Recursively write children\n\t\tif len(symbol.Children) \u003e 0 {\n\t\t\ttemp, err := writeSymbols(symbol.Children, depth+1)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t\toutput += temp\n\t\t}\n\t}\n\treturn output, nil\n}\n\nfunc dumpFiles(paths []PathInfo, skipBinary bool) (string, error) {\n\tvar sb strings.Builder\n\tsb.WriteString(\"## File Contents\\n\")\n\n\tfor _, path := range paths {\n\t\tif path.IsDir {\n\t\t\tcontinue\n\t\t}\n\n\t\tif skipBinary {\n\t\t\t// Check if file is binary\n\t\t\tisBinary, err := IsBinaryFile(path.Path)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", fmt.Errorf(\"checking if file %q is binary: %w\", path.Path, err)\n\t\t\t}\n\n\t\t\tif isBinary {\n\t\t\t\tsb.WriteString(\n\t\t\t\t\tfmt.Sprintf(\"\\n\\n--- File: %s\\n\u003cbinary file\u003e\", path.RelativePath),\n\t\t\t\t)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\t// Read and write file content\n\t\tfileContent, err := os.ReadFile(path.Path)\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"reading file %q: %w\", path.Path, err)\n\t\t}\n\n\t\tsb.WriteString(\n\t\t\tfmt.Sprintf(\"\\n--- Start File: %s\\n%s\\n--- End File: %s\\n\",\n\t\t\t\tpath.RelativePath, string(fileContent), path.RelativePath),\n\t\t)\n\t}\n\treturn sb.String(), nil\n}\n"
    },
    {
      "path": "amalgo/internal/output_json.go",
      "content": "package internal\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/Broderick-Westrope/amalgo/internal/parser\"\n)\n\ntype JSONDocument struct {\n\tTimestamp string            `json:\"timestamp\"`\n\tTree      string            `json:\"tree,omitempty\"`\n\tFiles     []JSONFile        `json:\"files,omitempty\"`\n\tOutlines  []JSONFileOutline `json:\"outlines,omitempty\"`\n}\n\ntype JSONFile struct {\n\tPath    string `json:\"path\"`\n\tContent string `json:\"content,omitempty\"`\n\tBinary  bool   `json:\"binary,omitempty\"`\n}\n\n// JSONFileOutline represents the parsed structure of a source file\ntype JSONFileOutline struct {\n\tPath    string       `json:\"path\"`\n\tSymbols []JSONSymbol `json:\"symbols,omitempty\"`\n\tErrors  []string     `json:\"errors,omitempty\"`\n}\n\n// JSONSymbol represents a parsed symbol (function, type, class, etc.)\ntype JSONSymbol struct {\n\tType          string       `json:\"type\"`                    // e.g., \"function\", \"class\", \"interface\"\n\tName          string       `json:\"name\"`                    // Name of the symbol\n\tSignature     string       `json:\"signature,omitempty\"`     // Full signature for functions/methods\n\tDocumentation string       `json:\"documentation,omitempty\"` // Associated documentation\n\tDecorators    []string     `json:\"decorators,omitempty\"`    // Any decorators/annotations\n\tChildren      []JSONSymbol `json:\"children,omitempty\"`      // Nested symbols (e.g., methods in a class)\n\tMetadata      any          `json:\"metadata,omitempty\"`      // Additional language-specific metadata\n}\n\nfunc generateOutputJSON(paths []PathInfo, registry *parser.Registry, opts OutputOptions) (string, error) {\n\tdoc := JSONDocument{\n\t\tTimestamp: FormatTimestamp(),\n\t}\n\n\tif !opts.NoTree {\n\t\tdoc.Tree = GenerateTree(paths)\n\t}\n\n\tif !opts.NoDump {\n\t\tfiles, err := generateFilesJSON(paths, opts.SkipBinary)\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"dumping files: %w\", err)\n\t\t}\n\t\tdoc.Files = files\n\t}\n\n\tif opts.Outline {\n\t\toutlines, err := generateOutlinesJSON(paths, registry)\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"generating outlines: %w\", err)\n\t\t}\n\t\tdoc.Outlines = outlines\n\t}\n\n\toutput, err := json.MarshalIndent(doc, \"\", \"  \")\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"marshaling JSON: %w\", err)\n\t}\n\n\treturn string(output) + \"\\n\", nil\n}\n\nfunc generateFilesJSON(paths []PathInfo, skipBinary bool) ([]JSONFile, error) {\n\tfiles := make([]JSONFile, 0, len(paths))\n\n\tfor _, path := range paths {\n\t\tif path.IsDir {\n\t\t\tcontinue\n\t\t}\n\n\t\tif skipBinary {\n\t\t\tisBinary, err := IsBinaryFile(path.Path)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"checking if binary: %w\", err)\n\t\t\t}\n\n\t\t\tif isBinary {\n\t\t\t\tfiles = append(files, JSONFile{\n\t\t\t\t\tPath:   path.RelativePath,\n\t\t\t\t\tBinary: true,\n\t\t\t\t})\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tcontent, err := os.ReadFile(path.Path)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"reading file %s: %w\", path.Path, err)\n\t\t}\n\n\t\tfiles = append(files, JSONFile{\n\t\t\tPath:    path.RelativePath,\n\t\t\tContent: string(content),\n\t\t})\n\t}\n\n\treturn files, nil\n}\n\nfunc generateOutlinesJSON(paths []PathInfo, registry *parser.Registry) ([]JSONFileOutline, error) {\n\toutlines := make([]JSONFileOutline, 0)\n\n\tfor _, path := range paths {\n\t\tif path.IsDir || !registry.IsSupported(path.Path) {\n\t\t\tcontinue\n\t\t}\n\n\t\tcontent, err := os.ReadFile(path.Path)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"reading file %s: %w\", path.Path, err)\n\t\t}\n\n\t\tparser := registry.GetParser(path.Path)\n\t\tparsedOutline, err := parser.Parse(content, path.Path)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"parsing file %s: %w\", path.Path, err)\n\t\t}\n\n\t\toutline := JSONFileOutline{\n\t\t\tPath:    path.RelativePath,\n\t\t\tSymbols: make([]JSONSymbol, 0, len(parsedOutline.Symbols)),\n\t\t}\n\n\t\t// Convert parser.Symbols to our JSON Symbol type\n\t\tfor _, sym := range parsedOutline.Symbols {\n\t\t\tsymbol, err := convertSymbol(sym)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"converting symbol in %s: %w\", path.Path, err)\n\t\t\t}\n\t\t\toutline.Symbols = append(outline.Symbols, symbol)\n\t\t}\n\n\t\t// Add any parsing errors\n\t\tif len(parsedOutline.Errors) \u003e 0 {\n\t\t\toutline.Errors = make([]string, len(parsedOutline.Errors))\n\t\t\tfor i, err := range parsedOutline.Errors {\n\t\t\t\toutline.Errors[i] = err.Error()\n\t\t\t}\n\t\t}\n\n\t\toutlines = append(outlines, outline)\n\t}\n\n\treturn outlines, nil\n}\n\nfunc convertSymbol(ps *parser.Symbol) (JSONSymbol, error) {\n\tchildren := make([]JSONSymbol, 0, len(ps.Children))\n\tfor _, child := range ps.Children {\n\t\tconverted, err := convertSymbol(child)\n\t\tif err != nil {\n\t\t\treturn JSONSymbol{}, fmt.Errorf(\"converting child symbol: %w\", err)\n\t\t}\n\t\tchildren = append(children, converted)\n\t}\n\n\treturn JSONSymbol{\n\t\tType:          ps.Type,\n\t\tName:          ps.Name,\n\t\tSignature:     ps.Signature,\n\t\tDocumentation: ps.Docstring,\n\t\tDecorators:    ps.Decorators,\n\t\tChildren:      children,\n\t\tMetadata:      ps.Metadata,\n\t}, nil\n}\n"
    },
    {
      "path": "amalgo/internal/parser/golang.go",
      "content": "package parser\n\nimport (\n\t\"go/ast\"\n\t\"go/parser\"\n\t\"go/token\"\n\t\"strings\"\n)\n\n// GoParser implements Parser for Go source files\ntype GoParser struct{}\n\n// NewGoParser creates a new Go parser\nfunc NewGoParser() *GoParser {\n\treturn \u0026GoParser{}\n}\n\nfunc (p *GoParser) Extensions() []string {\n\treturn []string{\".go\"}\n}\n\nfunc (p *GoParser) Parse(content []byte, filename string) (*FileOutline, error) {\n\tfset := token.NewFileSet()\n\tfile, err := parser.ParseFile(fset, filename, content, parser.ParseComments)\n\tif err != nil {\n\t\treturn \u0026FileOutline{\n\t\t\tFilename: filename,\n\t\t\tErrors:   []error{err},\n\t\t}, nil\n\t}\n\n\toutline := \u0026FileOutline{\n\t\tFilename: filename,\n\t\tSymbols:  make([]*Symbol, 0),\n\t}\n\n\t// Process package-level declarations\n\tfor _, decl := range file.Decls {\n\t\tsymbols := p.processDecl(decl, file)\n\t\toutline.Symbols = append(outline.Symbols, symbols...)\n\t}\n\n\treturn outline, nil\n}\n\nfunc (p *GoParser) processDecl(decl ast.Decl, file *ast.File) []*Symbol {\n\tvar symbols []*Symbol\n\n\tswitch d := decl.(type) {\n\tcase *ast.FuncDecl:\n\t\tsymbol := \u0026Symbol{\n\t\t\tType:      \"function\",\n\t\t\tName:      d.Name.Name,\n\t\t\tSignature: p.getFunctionSignature(d),\n\t\t\tDocstring: p.getDocstring(d.Doc),\n\t\t}\n\n\t\t// Handle methods\n\t\tif d.Recv != nil {\n\t\t\tsymbol.Type = \"method\"\n\t\t\tif len(d.Recv.List) \u003e 0 {\n\t\t\t\trecvType := p.typeToString(d.Recv.List[0].Type)\n\t\t\t\tsymbol.Name = recvType + \".\" + d.Name.Name\n\t\t\t}\n\t\t}\n\n\t\tsymbols = append(symbols, symbol)\n\n\tcase *ast.GenDecl:\n\t\tswitch d.Tok {\n\t\tcase token.TYPE:\n\t\t\tfor _, spec := range d.Specs {\n\t\t\t\tif typeSpec, ok := spec.(*ast.TypeSpec); ok {\n\t\t\t\t\tsymbol := \u0026Symbol{\n\t\t\t\t\t\tType:      p.getTypeSymbolType(typeSpec),\n\t\t\t\t\t\tName:      typeSpec.Name.Name,\n\t\t\t\t\t\tDocstring: p.getDocstring(d.Doc),\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle interface methods and struct fields\n\t\t\t\t\tif symbol.Type == \"interface\" {\n\t\t\t\t\t\tif iface, ok := typeSpec.Type.(*ast.InterfaceType); ok {\n\t\t\t\t\t\t\tsymbol.Children = p.processInterface(iface)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if symbol.Type == \"struct\" {\n\t\t\t\t\t\tif structType, ok := typeSpec.Type.(*ast.StructType); ok {\n\t\t\t\t\t\t\tsymbol.Children = p.processStruct(structType)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsymbols = append(symbols, symbol)\n\t\t\t\t}\n\t\t\t}\n\n\t\tcase token.CONST, token.VAR:\n\t\t\tfor _, spec := range d.Specs {\n\t\t\t\tif valSpec, ok := spec.(*ast.ValueSpec); ok {\n\t\t\t\t\tfor _, name := range valSpec.Names {\n\t\t\t\t\t\tsymbol := \u0026Symbol{\n\t\t\t\t\t\t\tType:      strings.ToLower(d.Tok.String()),\n\t\t\t\t\t\t\tName:      name.Name,\n\t\t\t\t\t\t\tDocstring: p.getDocstring(d.Doc),\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif valSpec.Type != nil {\n\t\t\t\t\t\t\tsymbol.Signature = p.typeToString(valSpec.Type)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsymbols = append(symbols, symbol)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn symbols\n}\n\nfunc (p *GoParser) processInterface(iface *ast.InterfaceType) []*Symbol {\n\tvar methods []*Symbol\n\tif iface.Methods == nil {\n\t\treturn methods\n\t}\n\n\tfor _, method := range iface.Methods.List {\n\t\tif len(method.Names) == 0 {\n\t\t\tcontinue // Skip embedded interfaces\n\t\t}\n\n\t\tmethodType, ok := method.Type.(*ast.FuncType)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, name := range method.Names {\n\t\t\tsymbol := \u0026Symbol{\n\t\t\t\tType:      \"method\",\n\t\t\t\tName:      name.Name,\n\t\t\t\tSignature: p.getFuncTypeSignature(methodType),\n\t\t\t\tDocstring: p.getDocstring(method.Doc),\n\t\t\t}\n\t\t\tmethods = append(methods, symbol)\n\t\t}\n\t}\n\n\treturn methods\n}\n\nfunc (p *GoParser) processStruct(structType *ast.StructType) []*Symbol {\n\tvar fields []*Symbol\n\tif structType.Fields == nil {\n\t\treturn fields\n\t}\n\n\tfor _, field := range structType.Fields.List {\n\t\tif len(field.Names) == 0 {\n\t\t\t// Anonymous/embedded field\n\t\t\tsymbol := \u0026Symbol{\n\t\t\t\tType:      \"field\",\n\t\t\t\tName:      p.typeToString(field.Type),\n\t\t\t\tSignature: p.typeToString(field.Type),\n\t\t\t\tDocstring: p.getDocstring(field.Doc),\n\t\t\t}\n\t\t\tfields = append(fields, symbol)\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, name := range field.Names {\n\t\t\tsymbol := \u0026Symbol{\n\t\t\t\tType:      \"field\",\n\t\t\t\tName:      name.Name,\n\t\t\t\tSignature: p.typeToString(field.Type),\n\t\t\t\tDocstring: p.getDocstring(field.Doc),\n\t\t\t}\n\t\t\tfields = append(fields, symbol)\n\t\t}\n\t}\n\n\treturn fields\n}\n\nfunc (p *GoParser) getFunctionSignature(fn *ast.FuncDecl) string {\n\tvar builder strings.Builder\n\tbuilder.WriteString(\"func \")\n\n\t// Add receiver if it's a method\n\tif fn.Recv != nil \u0026\u0026 len(fn.Recv.List) \u003e 0 {\n\t\tbuilder.WriteString(\"(\")\n\t\tif len(fn.Recv.List[0].Names) \u003e 0 {\n\t\t\tbuilder.WriteString(fn.Recv.List[0].Names[0].Name)\n\t\t\tbuilder.WriteString(\" \")\n\t\t}\n\t\tbuilder.WriteString(p.typeToString(fn.Recv.List[0].Type))\n\t\tbuilder.WriteString(\") \")\n\t}\n\n\tbuilder.WriteString(fn.Name.Name)\n\tbuilder.WriteString(p.getFuncTypeSignature(fn.Type))\n\treturn builder.String()\n}\n\nfunc (p *GoParser) getFuncTypeSignature(ft *ast.FuncType) string {\n\tvar builder strings.Builder\n\tbuilder.WriteString(\"(\")\n\n\tif ft.Params != nil {\n\t\tfor i, param := range ft.Params.List {\n\t\t\tif i \u003e 0 {\n\t\t\t\tbuilder.WriteString(\", \")\n\t\t\t}\n\t\t\tfor j, name := range param.Names {\n\t\t\t\tif j \u003e 0 {\n\t\t\t\t\tbuilder.WriteString(\", \")\n\t\t\t\t}\n\t\t\t\tbuilder.WriteString(name.Name)\n\t\t\t}\n\t\t\tif len(param.Names) \u003e 0 {\n\t\t\t\tbuilder.WriteString(\" \")\n\t\t\t}\n\t\t\tbuilder.WriteString(p.typeToString(param.Type))\n\t\t}\n\t}\n\n\tbuilder.WriteString(\")\")\n\n\tif ft.Results != nil {\n\t\tif ft.Results.NumFields() == 1 \u0026\u0026 len(ft.Results.List[0].Names) == 0 {\n\t\t\tbuilder.WriteString(\" \")\n\t\t\tbuilder.WriteString(p.typeToString(ft.Results.List[0].Type))\n\t\t} else {\n\t\t\tbuilder.WriteString(\" (\")\n\t\t\tfor i, result := range ft.Results.List {\n\t\t\t\tif i \u003e 0 {\n\t\t\t\t\tbuilder.WriteString(\", \")\n\t\t\t\t}\n\t\t\t\tfor j, name := range result.Names {\n\t\t\t\t\tif j \u003e 0 {\n\t\t\t\t\t\tbuilder.WriteString(\", \")\n\t\t\t\t\t}\n\t\t\t\t\tbuilder.WriteString(name.Name)\n\t\t\t\t}\n\t\t\t\tif len(result.Names) \u003e 0 {\n\t\t\t\t\tbuilder.WriteString(\" \")\n\t\t\t\t}\n\t\t\t\tbuilder.WriteString(p.typeToString(result.Type))\n\t\t\t}\n\t\t\tbuilder.WriteString(\")\")\n\t\t}\n\t}\n\n\treturn builder.String()\n}\n\nfunc (p *GoParser) typeToString(expr ast.Expr) string {\n\tswitch t := expr.(type) {\n\tcase *ast.Ident:\n\t\treturn t.Name\n\tcase *ast.SelectorExpr:\n\t\treturn p.typeToString(t.X) + \".\" + t.Sel.Name\n\tcase *ast.StarExpr:\n\t\treturn \"*\" + p.typeToString(t.X)\n\tcase *ast.ArrayType:\n\t\treturn \"[]\" + p.typeToString(t.Elt)\n\tcase *ast.MapType:\n\t\treturn \"map[\" + p.typeToString(t.Key) + \"]\" + p.typeToString(t.Value)\n\tcase *ast.InterfaceType:\n\t\treturn \"interface{}\"\n\tcase *ast.ChanType:\n\t\tswitch t.Dir {\n\t\tcase ast.SEND:\n\t\t\treturn \"chan\u003c- \" + p.typeToString(t.Value)\n\t\tcase ast.RECV:\n\t\t\treturn \"\u003c-chan \" + p.typeToString(t.Value)\n\t\tdefault:\n\t\t\treturn \"chan \" + p.typeToString(t.Value)\n\t\t}\n\tcase *ast.FuncType:\n\t\treturn \"func\" + p.getFuncTypeSignature(t)\n\tcase *ast.StructType:\n\t\treturn \"struct{...}\"\n\tcase *ast.Ellipsis:\n\t\treturn \"...\" + p.typeToString(t.Elt)\n\tdefault:\n\t\treturn \"\u003cunknown\u003e\"\n\t}\n}\n\nfunc (p *GoParser) getTypeSymbolType(typeSpec *ast.TypeSpec) string {\n\tswitch typeSpec.Type.(type) {\n\tcase *ast.InterfaceType:\n\t\treturn \"interface\"\n\tcase *ast.StructType:\n\t\treturn \"struct\"\n\tdefault:\n\t\treturn \"type\"\n\t}\n}\n\nfunc (p *GoParser) getDocstring(doc *ast.CommentGroup) string {\n\tif doc == nil {\n\t\treturn \"\"\n\t}\n\treturn doc.Text()\n}\n"
    },
    {
      "path": "amalgo/internal/parser/parser.go",
      "content": "// Package parser provides language-specific parsing capabilities\npackage parser\n\nimport \"path/filepath\"\n\n// Parser defines the interface for language-specific parsers\ntype Parser interface {\n\t// Parse analyzes the content of a file and returns a structured outline\n\tParse(content []byte, filename string) (*FileOutline, error)\n\n\t// Extensions returns the file extensions this parser handles\n\tExtensions() []string\n}\n\n// Symbol represents a parsed symbol (function, type, class, etc.)\ntype Symbol struct {\n\tType       string         // e.g., \"function\", \"class\", \"interface\", etc.\n\tName       string         // Name of the symbol\n\tSignature  string         // Full signature for functions/methods\n\tDocstring  string         // Associated documentation\n\tDecorators []string       // Any decorators/annotations\n\tChildren   []*Symbol      // Nested symbols (e.g., methods in a class)\n\tMetadata   map[string]any // Additional language-specific metadata\n}\n\n// FileOutline represents the parsed structure of a source file\ntype FileOutline struct {\n\tFilename string    // Name of the parsed file\n\tSymbols  []*Symbol // Top-level symbols in the file\n\tErrors   []error   // Any errors encountered during parsing\n}\n\n// Registry manages the available parsers\ntype Registry struct {\n\tparsers map[string]Parser\n}\n\n// NewRegistry creates a new parser registry\nfunc NewRegistry() *Registry {\n\treturn \u0026Registry{\n\t\tparsers: make(map[string]Parser),\n\t}\n}\n\n// Register adds a parser to the registry\nfunc (r *Registry) Register(parser Parser) {\n\tfor _, ext := range parser.Extensions() {\n\t\tr.parsers[ext] = parser\n\t}\n}\n\n// GetParser returns the appropriate parser for a file extension\nfunc (r *Registry) GetParser(filename string) Parser {\n\text := filepath.Ext(filename)\n\treturn r.parsers[ext]\n}\n\n// IsSupported checks if there's a parser available for the given file extension\nfunc (r *Registry) IsSupported(filename string) bool {\n\text := filepath.Ext(filename)\n\t_, ok := r.parsers[ext]\n\treturn ok\n}\n"
    },
    {
      "path": "amalgo/internal/traverse.go",
      "content": "package internal\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io/fs\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/Broderick-Westrope/amalgo/pkg/filter\"\n)\n\n// PathInfo represents information about a file or directory\ntype PathInfo struct {\n\tPath         string\n\tRelativePath string\n\tDepth        int\n\tIsDir        bool\n}\n\n// TraverseDirectory traverses the directory and collects path information using the filter package\nfunc TraverseDirectory(dir string, filterPatterns []string) ([]PathInfo, error) {\n\t// Create the filterer from patterns\n\tf := filter.CompileFilterPatterns(filterPatterns...)\n\n\tpaths := make([]PathInfo, 0)\n\tbasePath, err := filepath.Abs(dir)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"getting base path for directory %q: %w\", dir, err)\n\t}\n\n\tbaseInfo, err := os.Stat(basePath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"describing base path for directory %q: %w\", dir, err)\n\t}\n\n\tif !baseInfo.IsDir() {\n\t\tbasePath = filepath.Dir(basePath)\n\t\tbaseInfo, err = os.Stat(basePath)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif !baseInfo.IsDir() {\n\t\t\treturn nil, fmt.Errorf(\"expected base path %q to be a directory\", basePath)\n\t\t}\n\t}\n\n\t// Base parent allows getting the relative path in relation to the parent.\n\tbaseParent := filepath.Dir(basePath)\n\n\terr = filepath.WalkDir(basePath, func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"at path %q: %w\", path, err)\n\t\t}\n\n\t\t// Skip directories as the filter system is built to process file paths.\n\t\t// Skip the base path as it's already processed.\n\t\tif d.IsDir() || path == basePath {\n\t\t\treturn nil\n\t\t}\n\n\t\trelPath, err := filepath.Rel(basePath, path)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"getting relative path between %q and %q: %w\", basePath, path, err)\n\t\t}\n\n\t\t// Convert to forward slashes for consistent pattern matching\n\t\trelPath = filepath.ToSlash(relPath)\n\n\t\t// Check if a file path should be included based on patterns\n\t\tif f.MatchesPath(relPath) {\n\t\t\trelPath, err = filepath.Rel(baseParent, path)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"getting relative path between %q and %q: %w\", baseParent, path, err)\n\t\t\t}\n\n\t\t\tpaths = append(paths, PathInfo{\n\t\t\t\tPath:         path,\n\t\t\t\tRelativePath: relPath,\n\t\t\t\tDepth:        strings.Count(relPath, \"/\") + 1,\n\t\t\t\tIsDir:        false,\n\t\t\t})\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"walking directory %q: %w\", basePath, err)\n\t}\n\n\terr = processPaths(\u0026paths)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn paths, nil\n}\n\n// ProcessPaths adds all parent directory paths to the given slice of PathInfo.\n// The function modifies the input slice in place, adding parent directories in order\n// from shallowest to deepest, followed by the original paths.\nfunc processPaths(paths *[]PathInfo) error {\n\tif paths == nil {\n\t\treturn errors.New(\"paths must be a pointer to a slice\")\n\t} else if *paths == nil {\n\t\treturn errors.New(\"underlying paths slice cannot be nil\")\n\t}\n\n\t// Create a map to deduplicate paths.\n\tseen := make(map[string]struct{})\n\tfor _, path := range *paths {\n\t\tseen[path.Path] = struct{}{}\n\t}\n\n\tresult := make([]PathInfo, len(*paths))\n\tif copy(result, *paths) != len(*paths) {\n\t\treturn errors.New(\"failed to copy paths to result slice\")\n\t}\n\n\tfor _, p := range *paths {\n\t\t// Split the relative path to process each component.\n\t\tcomponents := strings.Split(p.RelativePath, \"/\")\n\t\tbasePath := filepath.Dir(p.Path[:len(p.Path)-len(p.RelativePath)])\n\n\t\t// Process each level of the path.\n\t\tcurrentRel := \"\"\n\t\tcurrentAbs := basePath\n\t\tfor i, comp := range components {\n\t\t\tif i == len(components)-1 \u0026\u0026 !p.IsDir {\n\t\t\t\t// Skip the last component if it's a file - we'll add it from the original slice.\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif currentRel == \"\" {\n\t\t\t\tcurrentRel = comp\n\t\t\t} else {\n\t\t\t\tcurrentRel = filepath.Join(currentRel, comp)\n\t\t\t}\n\t\t\tcurrentAbs = filepath.Join(currentAbs, comp)\n\n\t\t\t// Only add if we haven't seen this path before.\n\t\t\tif _, exists := seen[currentAbs]; !exists {\n\t\t\t\tseen[currentAbs] = struct{}{}\n\t\t\t\tresult = append(result, PathInfo{\n\t\t\t\t\tPath:         currentAbs,\n\t\t\t\t\tRelativePath: currentRel,\n\t\t\t\t\tDepth:        i + 1,\n\t\t\t\t\tIsDir:        true,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\t// Update the input slice with the result.\n\t*paths = result\n\treturn nil\n}\n"
    },
    {
      "path": "amalgo/internal/traverse_test.go",
      "content": "package internal\n\nimport (\n\t\"errors\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestTraverseDirectories(t *testing.T) {\n\t// Create a temporary directory structure for testing.\n\ttmpDir := t.TempDir()\n\n\t// Create test directory structure. Bool indicates if it's a directory.\n\ttestFiles := map[string]bool{\n\t\t\"src\":                   true,\n\t\t\"src/main.go\":           false,\n\t\t\"src/README.md\":         false,\n\t\t\"src/internal\":          true,\n\t\t\"src/internal/util.go\":  false,\n\t\t\"src/internal/test.txt\": false,\n\t\t\"vendor\":                true,\n\t\t\"vendor/lib.go\":         false,\n\t}\n\n\t// Create the test files and directories.\n\tfor path, isDir := range testFiles {\n\t\tfullPath := filepath.Join(tmpDir, path)\n\t\tif isDir {\n\t\t\trequire.NoError(t, os.MkdirAll(fullPath, 0755))\n\t\t} else {\n\t\t\trequire.NoError(t, os.MkdirAll(filepath.Dir(fullPath), 0755))\n\t\t\trequire.NoError(t, os.WriteFile(fullPath, []byte(\"test content\"), 0644))\n\t\t}\n\t}\n\n\ttests := map[string]struct {\n\t\tdirectory      string\n\t\tfilterPatterns []string\n\t\twantRelPaths   []string\n\t\twantErr        bool\n\t}{\n\t\t\"match go files in top directory\": {\n\t\t\tdirectory:      filepath.Join(tmpDir, \"src\"),\n\t\t\tfilterPatterns: []string{\"*.go\"},\n\t\t\twantRelPaths: []string{\n\t\t\t\t\"src/main.go\",\n\t\t\t},\n\t\t},\n\t\t\"match all go files\": {\n\t\t\tdirectory:      filepath.Join(tmpDir, \"src\"),\n\t\t\tfilterPatterns: []string{\"**/*.go\"},\n\t\t\twantRelPaths: []string{\n\t\t\t\t\"src/main.go\",\n\t\t\t\t\"src/internal/util.go\",\n\t\t\t},\n\t\t},\n\t\t\"exclude directory\": {\n\t\t\tdirectory:      filepath.Join(tmpDir, \"src\"),\n\t\t\tfilterPatterns: []string{\"*.go\", \"**/*.go\", \"!internal/**\"},\n\t\t\twantRelPaths: []string{\n\t\t\t\t\"src/main.go\",\n\t\t\t},\n\t\t},\n\t\t\"match specific directory\": {\n\t\t\tdirectory:      filepath.Join(tmpDir, \"src\", \"internal\"),\n\t\t\tfilterPatterns: []string{\"*\"},\n\t\t\twantRelPaths: []string{\n\t\t\t\t\"internal/util.go\",\n\t\t\t\t\"internal/test.txt\",\n\t\t\t},\n\t\t},\n\t\t\"non-existent directory\": {\n\t\t\tdirectory:      filepath.Join(tmpDir, \"nonexistent\"),\n\t\t\tfilterPatterns: []string{\"**/*.go\"},\n\t\t\twantErr:        true,\n\t\t},\n\t\t\"file as directory\": {\n\t\t\tdirectory:      filepath.Join(tmpDir, \"src\", \"main.go\"),\n\t\t\tfilterPatterns: []string{\"*.go\"},\n\t\t\twantRelPaths: []string{\n\t\t\t\t\"src/main.go\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tt := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tpaths, err := TraverseDirectory(tt.directory, tt.filterPatterns)\n\n\t\t\tif tt.wantErr {\n\t\t\t\trequire.Error(t, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Convert PathInfo slice to relative paths for easier comparison.\n\t\t\tvar gotPaths []string\n\t\t\tfor _, p := range paths {\n\t\t\t\tif !p.IsDir { // Only include files in our comparison\n\t\t\t\t\tgotPaths = append(gotPaths, p.RelativePath)\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert.ElementsMatch(t, tt.wantRelPaths, gotPaths)\n\n\t\t\t// Additional validation of PathInfo fields.\n\t\t\tfor _, p := range paths {\n\t\t\t\t// Paths should be absolute.\n\t\t\t\tassert.True(t, filepath.IsAbs(p.Path), \"Path should be absolute: %s\", p.Path)\n\n\t\t\t\t// RelativePath should not be absolute.\n\t\t\t\tassert.False(t, filepath.IsAbs(p.RelativePath), \"RelativePath should be relative: %s\", p.RelativePath)\n\n\t\t\t\t// Depth should match the number of path separators plus one.\n\t\t\t\texpectedDepth := 0\n\t\t\t\tif p.RelativePath != \"\" {\n\t\t\t\t\texpectedDepth = len(strings.Split(p.RelativePath, \"/\"))\n\t\t\t\t}\n\t\t\t\tassert.Equal(t, expectedDepth, p.Depth, \"Incorrect depth for path: %s\", p.RelativePath)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestProcessPaths(t *testing.T) {\n\tvar nilPathInfoSlice []PathInfo = nil\n\ttests := map[string]struct {\n\t\tpaths     *[]PathInfo\n\t\twantPaths []PathInfo\n\t\twantErr   error\n\t}{\n\t\t\"single file adds parent dirs\": {\n\t\t\tpaths: \u0026[]PathInfo{\n\t\t\t\t{\n\t\t\t\t\tPath:         \"/Users/someuser/dev/program/internal/file1.go\",\n\t\t\t\t\tRelativePath: \"program/internal/file1.go\",\n\t\t\t\t\tDepth:        3,\n\t\t\t\t\tIsDir:        false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPaths: []PathInfo{\n\t\t\t\t{\n\t\t\t\t\tPath:         \"/Users/someuser/dev/program/internal/file1.go\",\n\t\t\t\t\tRelativePath: \"program/internal/file1.go\",\n\t\t\t\t\tDepth:        3,\n\t\t\t\t\tIsDir:        false,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPath:         \"/Users/someuser/dev/program\",\n\t\t\t\t\tRelativePath: \"program\",\n\t\t\t\t\tDepth:        1,\n\t\t\t\t\tIsDir:        true,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPath:         \"/Users/someuser/dev/program/internal\",\n\t\t\t\t\tRelativePath: \"program/internal\",\n\t\t\t\t\tDepth:        2,\n\t\t\t\t\tIsDir:        true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"multiple files same directory\": {\n\t\t\tpaths: \u0026[]PathInfo{\n\t\t\t\t{\n\t\t\t\t\tPath:         \"/Users/someuser/dev/program/internal/file1.go\",\n\t\t\t\t\tRelativePath: \"program/internal/file1.go\",\n\t\t\t\t\tDepth:        3,\n\t\t\t\t\tIsDir:        false,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPath:         \"/Users/someuser/dev/program/internal/file2.go\",\n\t\t\t\t\tRelativePath: \"program/internal/file2.go\",\n\t\t\t\t\tDepth:        3,\n\t\t\t\t\tIsDir:        false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPaths: []PathInfo{\n\t\t\t\t{\n\t\t\t\t\tPath:         \"/Users/someuser/dev/program/internal/file1.go\",\n\t\t\t\t\tRelativePath: \"program/internal/file1.go\",\n\t\t\t\t\tDepth:        3,\n\t\t\t\t\tIsDir:        false,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPath:         \"/Users/someuser/dev/program/internal/file2.go\",\n\t\t\t\t\tRelativePath: \"program/internal/file2.go\",\n\t\t\t\t\tDepth:        3,\n\t\t\t\t\tIsDir:        false,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPath:         \"/Users/someuser/dev/program\",\n\t\t\t\t\tRelativePath: \"program\",\n\t\t\t\t\tDepth:        1,\n\t\t\t\t\tIsDir:        true,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPath:         \"/Users/someuser/dev/program/internal\",\n\t\t\t\t\tRelativePath: \"program/internal\",\n\t\t\t\t\tDepth:        2,\n\t\t\t\t\tIsDir:        true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"different directory depths\": {\n\t\t\tpaths: \u0026[]PathInfo{\n\t\t\t\t{\n\t\t\t\t\tPath:         \"/Users/someuser/dev/program/file1.go\",\n\t\t\t\t\tRelativePath: \"program/file1.go\",\n\t\t\t\t\tDepth:        2,\n\t\t\t\t\tIsDir:        false,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPath:         \"/Users/someuser/dev/program/internal/deep/file2.go\",\n\t\t\t\t\tRelativePath: \"program/internal/deep/file2.go\",\n\t\t\t\t\tDepth:        4,\n\t\t\t\t\tIsDir:        false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPaths: []PathInfo{\n\t\t\t\t{\n\t\t\t\t\tPath:         \"/Users/someuser/dev/program/file1.go\",\n\t\t\t\t\tRelativePath: \"program/file1.go\",\n\t\t\t\t\tDepth:        2,\n\t\t\t\t\tIsDir:        false,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPath:         \"/Users/someuser/dev/program/internal/deep/file2.go\",\n\t\t\t\t\tRelativePath: \"program/internal/deep/file2.go\",\n\t\t\t\t\tDepth:        4,\n\t\t\t\t\tIsDir:        false,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPath:         \"/Users/someuser/dev/program\",\n\t\t\t\t\tRelativePath: \"program\",\n\t\t\t\t\tDepth:        1,\n\t\t\t\t\tIsDir:        true,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPath:         \"/Users/someuser/dev/program/internal\",\n\t\t\t\t\tRelativePath: \"program/internal\",\n\t\t\t\t\tDepth:        2,\n\t\t\t\t\tIsDir:        true,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPath:         \"/Users/someuser/dev/program/internal/deep\",\n\t\t\t\t\tRelativePath: \"program/internal/deep\",\n\t\t\t\t\tDepth:        3,\n\t\t\t\t\tIsDir:        true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"directory included\": {\n\t\t\tpaths: \u0026[]PathInfo{\n\t\t\t\t{\n\t\t\t\t\tPath:         \"/Users/someuser/dev/program/internal\",\n\t\t\t\t\tRelativePath: \"program/internal\",\n\t\t\t\t\tDepth:        2,\n\t\t\t\t\tIsDir:        true,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPath:         \"/Users/someuser/dev/program/internal/file1.go\",\n\t\t\t\t\tRelativePath: \"program/internal/file1.go\",\n\t\t\t\t\tDepth:        3,\n\t\t\t\t\tIsDir:        false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPaths: []PathInfo{\n\t\t\t\t{\n\t\t\t\t\tPath:         \"/Users/someuser/dev/program/internal\",\n\t\t\t\t\tRelativePath: \"program/internal\",\n\t\t\t\t\tDepth:        2,\n\t\t\t\t\tIsDir:        true,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPath:         \"/Users/someuser/dev/program/internal/file1.go\",\n\t\t\t\t\tRelativePath: \"program/internal/file1.go\",\n\t\t\t\t\tDepth:        3,\n\t\t\t\t\tIsDir:        false,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPath:         \"/Users/someuser/dev/program\",\n\t\t\t\t\tRelativePath: \"program\",\n\t\t\t\t\tDepth:        1,\n\t\t\t\t\tIsDir:        true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"empty slice\": {\n\t\t\tpaths:     \u0026[]PathInfo{},\n\t\t\twantPaths: []PathInfo{},\n\t\t},\n\t\t\"nil slice\": {\n\t\t\tpaths:     \u0026nilPathInfoSlice,\n\t\t\twantPaths: []PathInfo{},\n\t\t\twantErr:   errors.New(\"underlying paths slice cannot be nil\"),\n\t\t},\n\t\t\"nil pointer\": {\n\t\t\tpaths:     nil,\n\t\t\twantPaths: []PathInfo{},\n\t\t\twantErr:   errors.New(\"paths must be a pointer to a slice\"),\n\t\t},\n\t}\n\n\tfor name, tt := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\terr := processPaths(tt.paths)\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tassert.EqualError(t, err, tt.wantErr.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t\trequire.NoError(t, err)\n\n\t\t\tassert.Equal(t, tt.wantPaths, *tt.paths)\n\t\t})\n\t}\n}\n"
    },
    {
      "path": "amalgo/internal/utils.go",
      "content": "package internal\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"time\"\n)\n\n// IsBinaryFile determines if a file is binary by checking its contents\nfunc IsBinaryFile(path string) (bool, error) {\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"opening file: %w\", err)\n\t}\n\tdefer file.Close()\n\n\t// Read first 512 bytes\n\tbuf := make([]byte, 512)\n\tn, err := file.Read(buf)\n\tif err != nil \u0026\u0026 err != io.EOF {\n\t\treturn false, fmt.Errorf(\"reading file: %w\", err)\n\t}\n\tbuf = buf[:n]\n\n\t// Check for null bytes\n\tif bytes.IndexByte(buf, 0) != -1 {\n\t\treturn true, nil\n\t}\n\n\t// Look for non-text characters\n\tfor _, b := range buf {\n\t\tif b \u003c 32 \u0026\u0026 b != 9 \u0026\u0026 b != 10 \u0026\u0026 b != 13 { // Not tab, LF, or CR\n\t\t\treturn true, nil\n\t\t}\n\t}\n\treturn false, nil\n}\n\n// GenerateTree creates a textual representation of the directory structure\nfunc GenerateTree(paths []PathInfo) string {\n\tif len(paths) == 0 {\n\t\treturn \"\u003c no paths found \u003e\\n\"\n\t}\n\n\tmapPathToChildren := make(map[string][]PathInfo)\n\tfor _, path := range paths {\n\t\tif path.Depth == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tparent := filepath.Dir(path.Path)\n\t\tmapPathToChildren[parent] = append(mapPathToChildren[parent], path)\n\t}\n\n\tvar output string\n\tvar printTree func(path PathInfo, prefix string, isLast bool)\n\tprintTree = func(path PathInfo, prefix string, isLast bool) {\n\t\t// Print current item\n\t\tconnector := \"├── \"\n\t\tif isLast {\n\t\t\tconnector = \"└── \"\n\t\t}\n\n\t\tname := filepath.Base(path.Path)\n\t\tif path.IsDir {\n\t\t\tname += \"/\"\n\t\t}\n\t\toutput += fmt.Sprintf(\"%s%s%s\\n\", prefix, connector, name)\n\n\t\t// Print children\n\t\tchildPrefix := prefix + \"│   \"\n\t\tif isLast {\n\t\t\tchildPrefix = prefix + \"    \"\n\t\t}\n\n\t\tpathChildren := mapPathToChildren[path.Path]\n\t\tfor i, child := range pathChildren {\n\t\t\tprintTree(child, childPrefix, i == len(pathChildren)-1)\n\t\t}\n\t}\n\n\tshortestPath := paths[0]\n\tfor _, path := range paths {\n\t\tif len(path.Path) \u003c len(shortestPath.Path) {\n\t\t\tshortestPath = path\n\t\t}\n\t}\n\n\t// Find and process root level items.\n\trootPaths := mapPathToChildren[filepath.Dir(shortestPath.Path)]\n\tfor i, path := range rootPaths {\n\t\tprintTree(path, \"\", i == len(rootPaths)-1)\n\t}\n\treturn output\n}\n\n// WriteOutput writes content to a file or stdout\nfunc WriteOutput(path string, content string) error {\n\tif path == \"stdout\" || path == \"-\" {\n\t\t_, err := fmt.Print(content)\n\t\treturn fmt.Errorf(\"writing to stdout: %w\", err)\n\t}\n\n\tdir := filepath.Dir(path)\n\terr := os.MkdirAll(dir, 0755)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"creating directories along path %q: %w\", dir, err)\n\t}\n\n\terr = os.WriteFile(path, []byte(content), 0644)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"writing to file: %w\", err)\n\t}\n\treturn nil\n}\n\n// FormatTimestamp returns a formatted timestamp string\nfunc FormatTimestamp() string {\n\treturn time.Now().Format(\"2006-01-02 15:04:05\")\n}\n"
    },
    {
      "path": "amalgo/main.go",
      "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/Broderick-Westrope/amalgo/internal\"\n\t\"github.com/Broderick-Westrope/amalgo/internal/parser\"\n\t\"github.com/alecthomas/kong\"\n\t\"github.com/fatih/color\"\n)\n\nconst (\n\tappName = \"amalgo\"\n\tversion = \"0.4.0\"\n)\n\nfunc main() {\n\tos.Exit(run())\n}\n\nfunc run() int {\n\tcli := RootCmd{\n\t\tVersion: versionFlag(version),\n\t}\n\n\texitHandler := \u0026exitWriter{}\n\tctx := kong.Parse(\u0026cli,\n\t\tkong.Name(appName),\n\t\tkong.Description(\"Create consolidated snapshots of source code for analysis, documentation, and sharing with LLMs.\"),\n\t\tkong.UsageOnError(),\n\t\tkong.Writers(os.Stdout, exitHandler),\n\t\tkong.Exit(exitHandler.Exit),\n\t\tkong.DefaultEnvars(appName),\n\t\tkong.Vars{\"version\": string(cli.Version)},\n\t)\n\n\tif exitHandler.code != 0 {\n\t\tfmt.Fprintf(os.Stderr, \"%s\", exitHandler.message)\n\t\treturn exitHandler.code\n\t}\n\n\terr := ctx.Run()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error: %v\\n\", err)\n\t\treturn 1\n\t}\n\treturn 0\n}\n\ntype RootCmd struct {\n\t// Default command args and flags\n\tDir           string                `arg:\"\" optional:\"\" help:\"Directory to analyze. If a file is provided it's parent directory will be used.\" type:\"path\" default:\".\"`\n\tOutput        string                `help:\"Specifies the destination path for the output file. The file extension will automatically adjust based on the selected format (see '--format').\" short:\"o\" type:\"path\" placeholder:\"amalgo.txt\"`\n\tStdout        bool                  `help:\"Redirects all output to standard output (terminal) instead of writing to a file. Useful for piping output to other commands.\"`\n\tFilter        []string              `help:\"Controls which files are processed using glob patterns. Include patterns are processed first, then exclude patterns (prefixed with '!'). Hidden files and directories are excluded by default.\" short:\"f\" default:\"*,!.*\"`\n\tNoTree        bool                  `help:\"Skips the inclusion of the file tree in the output.\" default:\"false\"`\n\tNoDump        bool                  `help:\"Skips the inclusion of file contents in the output.\" default:\"false\"`\n\tOutline       bool                  `help:\"Includes in the output a language-aware outline of code files, showing functions, classes, and other significant elements. Only available for specific file extensions: '.go'.\" default:\"false\"`\n\tNoColor       bool                  `help:\"Disables ANSI color codes in the output.\" default:\"false\"`\n\tIncludeBinary bool                  `help:\"Processes binary files instead of skipping them. Use with caution as this may produce large or unreadable output.\" default:\"false\"`\n\tFormat        internal.OutputFormat `help:\"Selects an alternative output format. This affects both the structure and the file extension of the output. Options: 'default', 'json'.\" enum:\"default,json\" default:\"default\"`\n\n\t// Subcommands\n\tVersion versionFlag `help:\"Displays the current version of the tool and exits immediately.\" short:\"v\" name:\"version\"`\n}\n\nfunc (c *RootCmd) validate() bool {\n\tif c.Output == \"\" {\n\t\tif c.Format == internal.OutputFormatJSON {\n\t\t\tc.Output += \"amalgo.json\"\n\t\t} else {\n\t\t\tc.Output = \"amalgo.txt\"\n\t\t}\n\t}\n\n\tissues := make([]string, 0)\n\tif c.NoDump \u0026\u0026 c.NoTree \u0026\u0026 !c.Outline {\n\t\tissues = append(issues, \"An empty output is not allowed (no dump, no tree, and no outline).\")\n\t}\n\n\tif len(issues) == 0 {\n\t\treturn true\n\t}\n\tout := strings.Join(issues, \"\\n\")\n\tif !c.NoColor {\n\t\tout = color.RedString(out)\n\t}\n\tfmt.Println(out)\n\treturn false\n}\n\nfunc (c *RootCmd) Run() error {\n\tif !c.validate() {\n\t\treturn nil\n\t}\n\n\toutputDest := c.Output\n\tif c.Stdout {\n\t\toutputDest = \"stdout\"\n\t}\n\n\tregistry := parser.NewRegistry()\n\tregistry.Register(parser.NewGoParser())\n\n\tpaths, err := internal.TraverseDirectory(c.Dir, c.Filter)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"traversing directories: %w\", err)\n\t}\n\n\toutputOpts := internal.OutputOptions{\n\t\tNoTree:     c.NoTree,\n\t\tNoDump:     c.NoDump,\n\t\tOutline:    c.Outline,\n\t\tSkipBinary: !c.IncludeBinary,\n\t\tFormat:     c.Format,\n\t}\n\n\toutput, err := internal.GenerateOutput(paths, registry, outputOpts)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"generating output: %w\", err)\n\t}\n\n\terr = internal.WriteOutput(outputDest, output)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"writing output: %w\", err)\n\t}\n\n\t// Print success message unless output is stdout.\n\tif outputDest != \"stdout\" {\n\t\tmsg := fmt.Sprintf(\"Successfully generated output to: %s\\n\", outputDest)\n\t\tif !c.NoColor {\n\t\t\tmsg = color.GreenString(msg)\n\t\t}\n\t\tfmt.Print(msg)\n\t}\n\n\treturn nil\n}\n\ntype versionFlag string\n\nfunc (v versionFlag) Decode(_ *kong.DecodeContext) error { return nil }\nfunc (v versionFlag) IsBool() bool                       { return true }\nfunc (v versionFlag) BeforeApply(app *kong.Kong, vars kong.Vars) error {\n\tfmt.Println(vars[\"version\"])\n\tapp.Exit(0)\n\treturn nil\n}\n\n// Custom writer that can capture output for testing\ntype exitWriter struct {\n\tcode    int\n\tmessage string\n}\n\nfunc (w *exitWriter) Write(p []byte) (n int, err error) {\n\tw.message += string(p)\n\treturn len(p), nil\n}\n\nfunc (w *exitWriter) Exit(code int) {\n\tw.code = code\n}\n"
    },
    {
      "path": "amalgo/main_test.go",
      "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/fatih/color\"\n\t\"github.com/rogpeppe/go-internal/testscript\"\n\t\"github.com/sergi/go-diff/diffmatchpatch\"\n)\n\nfunc TestMain(m *testing.M) {\n\tcolor.NoColor = false\n\tos.Exit(testscript.RunMain(m,\n\t\tmap[string]func() int{\n\t\t\tappName: run,\n\t\t},\n\t))\n}\n\nfunc TestScript(t *testing.T) {\n\ttestscript.Run(t, testscript.Params{\n\t\tDir: \"testdata/script\",\n\t\tSetup: func(env *testscript.Env) error {\n\t\t\treturn nil\n\t\t},\n\t\tCmds: map[string]func(ts *testscript.TestScript, neg bool, args []string){\n\t\t\t\"cmpfile\": compareFiles,\n\t\t\t\"showfile\": func(ts *testscript.TestScript, neg bool, args []string) {\n\t\t\t\tif len(args) != 1 {\n\t\t\t\t\tts.Fatalf(\"usage: showfile filename\")\n\t\t\t\t}\n\t\t\t\tcontent, err := os.ReadFile(ts.MkAbs(args[0]))\n\t\t\t\tif err != nil {\n\t\t\t\t\tts.Fatalf(\"reading %s: %v\", args[0], err)\n\t\t\t\t}\n\t\t\t\tfmt.Fprintf(ts.Stdout(), \"=== Content of %s ===\\n\", args[0])\n\t\t\t\tfmt.Fprintf(ts.Stdout(), \"%s\\n\", content)\n\t\t\t\tfmt.Fprintf(ts.Stdout(), \"=== End of %s ===\\n\", args[0])\n\t\t\t},\n\t\t},\n\t})\n}\n\nfunc compareFiles(ts *testscript.TestScript, neg bool, args []string) {\n\tif len(args) != 2 {\n\t\tts.Fatalf(\"usage: cmpfile actual expected\")\n\t}\n\ttemp := ts.MkAbs(args[0])\n\tactual, err := os.ReadFile(temp)\n\tif err != nil {\n\t\tts.Fatalf(\"reading %q (actual): %v\", temp, err)\n\t}\n\ttemp = ts.MkAbs(args[1])\n\texpected, err := os.ReadFile(temp)\n\tif err != nil {\n\t\tts.Fatalf(\"reading %q (expected): %v\", temp, err)\n\t}\n\n\t// Split into lines\n\tactualLines := strings.Split(string(actual), \"\\n\")\n\texpectedLines := strings.Split(string(expected), \"\\n\")\n\n\t// Create debug versions with visible empty lines\n\tdebugActual := make([]string, len(actualLines))\n\tdebugExpected := make([]string, len(expectedLines))\n\n\tfor i, line := range actualLines {\n\t\tif line == \"\" {\n\t\t\tdebugActual[i] = \"\u003cempty\u003e\"\n\t\t} else {\n\t\t\tdebugActual[i] = line\n\t\t}\n\t}\n\n\tfor i, line := range expectedLines {\n\t\tif line == \"\" {\n\t\t\tdebugExpected[i] = \"\u003cempty\u003e\"\n\t\t} else {\n\t\t\tdebugExpected[i] = line\n\t\t}\n\t}\n\n\tmatchFailed := false\n\tif len(actualLines) != len(expectedLines) {\n\t\tif !neg {\n\t\t\tmatchFailed = true\n\t\t}\n\t}\n\n\tfor i := 0; i \u003c len(actualLines) \u0026\u0026 i \u003c len(expectedLines); i++ {\n\t\taLine := actualLines[i]\n\t\teLine := expectedLines[i]\n\t\t// Skip timestamp line\n\t\tif strings.Contains(aLine, \"Generated with Amalgo at:\") || strings.Contains(aLine, \"timestamp\") {\n\t\t\tcontinue\n\t\t}\n\t\tif aLine != eLine {\n\t\t\tmatchFailed = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif matchFailed {\n\t\tdiffStr := createDiff(\n\t\t\tfmt.Sprintf(\"Expected (%d lines)\", len(expectedLines)),\n\t\t\tfmt.Sprintf(\"Actual (%d lines)\", len(actualLines)),\n\t\t\tstrings.Join(debugExpected, \"\\n\"),\n\t\t\tstrings.Join(debugActual, \"\\n\"),\n\t\t)\n\t\tts.Fatalf(\"Failed to match:\\n%s\", diffStr)\n\t} else if neg {\n\t\tts.Fatalf(\"files match but should not\")\n\t}\n}\n\nfunc createDiff(name1, name2, text1, text2 string) string {\n\tdmp := diffmatchpatch.New()\n\tdiffs := dmp.DiffMain(text1, text2, false)\n\treturn fmt.Sprintf(\n\t\t\"%s\\n%s\\n%s\",\n\t\tcolor.RedString(\"--- \"+name1),\n\t\tcolor.GreenString(\"+++ \"+name2),\n\t\tdmp.DiffPrettyText(diffs),\n\t)\n}\n"
    },
    {
      "path": "amalgo/pkg/filter/filter.go",
      "content": "// Package filter provides functionality for matching paths against exclusion patterns\n// using a syntax similar to gitignore - patterns indicate what to include (match against)\n// unless prefixed with '!'. This can be used for both file inclusion and exclusion.\npackage filter\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n)\n\n// Filterer wraps a list of filter patterns.\ntype Filterer struct {\n\tpatterns []*Pattern\n}\n\n// Pattern encapsulates a regexp pattern and whether it is negated.\ntype Pattern struct {\n\tPattern *regexp.Regexp\n\tNegate  bool\n\tLineNo  int\n\tLine    string\n}\n\n// MatchesPath returns true if the path matches the patterns.\nfunc (f *Filterer) MatchesPath(path string) bool {\n\tmatches, _ := f.MatchesPathHow(path)\n\treturn matches\n}\n\n// MatchesPathHow returns whether the path matches and which pattern matched it.\nfunc (f *Filterer) MatchesPathHow(path string) (bool, *Pattern) {\n\t// Normalize path separators.\n\tpath = filepath.ToSlash(path)\n\n\tvar matchingPattern *Pattern\n\tmatchesPath := false\n\n\tfor _, pattern := range f.patterns {\n\t\tif pattern.Pattern.MatchString(path) {\n\t\t\tif !pattern.Negate {\n\t\t\t\tmatchesPath = true\n\t\t\t\tmatchingPattern = pattern\n\t\t\t} else if matchesPath {\n\t\t\t\t// Path was previously matched but now negated.\n\t\t\t\tmatchesPath = false\n\t\t\t\tmatchingPattern = pattern\n\t\t\t}\n\t\t}\n\t}\n\treturn matchesPath, matchingPattern\n}\n\n// CompileFilterPatterns accepts a variadic set of strings and returns a Filterer\n// instance with the compiled patterns.\nfunc CompileFilterPatterns(patterns ...string) *Filterer {\n\tf := new(Filterer)\n\tfor i, pattern := range patterns {\n\t\tpattern = strings.TrimRight(pattern, \"\\r\")\n\t\tpattern = strings.TrimSpace(pattern)\n\t\tcompiledPattern, isNegated := getPatternFromLine(pattern)\n\t\tif compiledPattern != nil {\n\t\t\tfp := \u0026Pattern{compiledPattern, isNegated, i + 1, pattern}\n\t\t\tf.patterns = append(f.patterns, fp)\n\t\t}\n\t}\n\treturn f\n}\n\n// CompileFilterPatternFile reads patterns from a file and compiles them.\nfunc CompileFilterPatternFile(path string) (*Filterer, error) {\n\tbs, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpatterns := strings.Split(string(bs), \"\\n\")\n\treturn CompileFilterPatterns(patterns...), nil\n}\n\n// CompileExcludePatternFileAndLines compiles patterns from both a file and additional lines.\nfunc CompileFilterPatternFileAndLines(path string, lines ...string) (*Filterer, error) {\n\tbs, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpatterns := append(strings.Split(string(bs), \"\\n\"), lines...)\n\treturn CompileFilterPatterns(patterns...), nil\n}\n\n// getPatternFromLine converts a single pattern line into a regexp and bool indicating\n// if it's a negated pattern. The rules follow .gitignore syntax.\nfunc getPatternFromLine(line string) (*regexp.Regexp, bool) {\n\t// Strip comments.\n\tif strings.HasPrefix(line, \"#\") {\n\t\treturn nil, false\n\t}\n\n\t// Skip empty lines.\n\tif line == \"\" {\n\t\treturn nil, false\n\t}\n\n\t// Check for negation prefix. Several will negate the previous negation (ie. toggling).\n\tnegatePattern := false\n\tfor line[0] == '!' {\n\t\tnegatePattern = !negatePattern\n\t\tline = line[1:]\n\t}\n\n\t// Create a copy of the line to modify. The original is maintained for later checks.\n\texpr := line\n\n\t// Ignore a prefix of escaped '#' or '!'.\n\tif regexp.MustCompile(`^(\\#|\\!)`).MatchString(expr) {\n\t\texpr = expr[1:]\n\t}\n\n\t// Escape dots.\n\texpr = regexp.MustCompile(`\\.`).ReplaceAllString(expr, `\\.`)\n\n\t// This 'magic star\" is used temporarily when handling other single-star cases.\n\tmagicStar := \"#$~\"\n\n\t// Handle '/**/' patterns.\n\tif strings.HasPrefix(expr, \"/**/\") {\n\t\texpr = expr[1:]\n\t}\n\texpr = regexp.MustCompile(`/\\*\\*/`).ReplaceAllString(expr, `(/|/.+/)`)\n\texpr = regexp.MustCompile(`\\*\\*/`).ReplaceAllString(expr, `(|.`+magicStar+`/)`)\n\texpr = regexp.MustCompile(`/\\*\\*`).ReplaceAllString(expr, `(|/.`+magicStar+`)`)\n\n\t// Handle wildcards.\n\texpr = regexp.MustCompile(`\\\\\\*`).ReplaceAllString(expr, `\\`+magicStar)\n\texpr = regexp.MustCompile(`\\*`).ReplaceAllString(expr, `([^/]*)`) // '*' may be any number of characters other than '/'\n\texpr = strings.Replace(expr, \"?\", `[^/]`, -1)                     // '?' may be any single character other than '/'\n\texpr = strings.Replace(expr, magicStar, \"*\", -1)\n\n\t// Build final regex.\n\tif strings.HasSuffix(line, \"/\") {\n\t\texpr += \"(|.*)$\"\n\t} else {\n\t\texpr += \"(|/.*)$\"\n\t}\n\n\t// Only add directory prefix for patterns starting with /\n\tswitch {\n\tcase strings.HasPrefix(line, \"/\"):\n\t\texpr = \"^(|/)\" + expr[1:]\n\n\tcase strings.HasPrefix(line, \"**/\"):\n\t\t// Pattern contains a slash but doesn't start with one\n\t\texpr = \"^(|.*/)\" + expr\n\n\tdefault:\n\t\t// Simple pattern like *.go - should only match in current directory\n\t\texpr = \"^\" + expr\n\t}\n\n\tpattern, _ := regexp.Compile(expr)\n\treturn pattern, negatePattern\n}\n"
    },
    {
      "path": "amalgo/pkg/filter/filter_test.go",
      "content": "package filter\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestMatchesPath(t *testing.T) {\n\ttests := map[string]struct {\n\t\tpatterns []string\n\t\tpath     string\n\t\twant     bool\n\t}{\n\t\t\"double asterisk at start\": {\n\t\t\tpatterns: []string{\"**/test.txt\"},\n\t\t\tpath:     \"deep/nested/test.txt\",\n\t\t\twant:     true,\n\t\t},\n\t\t\"double asterisk in middle\": {\n\t\t\tpatterns: []string{\"src/**/test.txt\"},\n\t\t\tpath:     \"src/deeply/nested/test.txt\",\n\t\t\twant:     true,\n\t\t},\n\t\t\"double asterisk at end\": {\n\t\t\tpatterns: []string{\"src/**\"},\n\t\t\tpath:     \"src/any/number/of/subdirs\",\n\t\t\twant:     true,\n\t\t},\n\t\t\"leading slash\": {\n\t\t\tpatterns: []string{\"/root.txt\"},\n\t\t\tpath:     \"root.txt\",\n\t\t\twant:     true,\n\t\t},\n\t\t\"single character wildcard\": {\n\t\t\tpatterns: []string{\"test?.txt\"},\n\t\t\tpath:     \"test1.txt\",\n\t\t\twant:     true,\n\t\t},\n\t\t\"actual dots in filenames\": {\n\t\t\tpatterns: []string{\"*.txt\"},\n\t\t\tpath:     \"file.txt\",\n\t\t\twant:     true,\n\t\t},\n\t\t\"multiple extensions separate patterns\": {\n\t\t\tpatterns: []string{\"*.txt\", \"*.md\", \"*.json\"},\n\t\t\tpath:     \"file.json\",\n\t\t\twant:     true,\n\t\t},\n\t\t\"complex nesting with negation\": {\n\t\t\tpatterns: []string{\n\t\t\t\t\"**/*.go\",\n\t\t\t\t\"!vendor/**\",\n\t\t\t\t\"vendor/allowed/*.go\",\n\t\t\t},\n\t\t\tpath: \"vendor/forbidden/file.go\",\n\t\t\twant: false,\n\t\t},\n\t\t\"multiple patterns with precedence\": {\n\t\t\tpatterns: []string{\n\t\t\t\t\"*.txt\",\n\t\t\t\t\"!important/*.txt\",\n\t\t\t\t\"important/keepthis.txt\",\n\t\t\t},\n\t\t\tpath: \"important/keepthis.txt\",\n\t\t\twant: true,\n\t\t},\n\t\t\"spaces in pattern\": {\n\t\t\tpatterns: []string{\" *.txt \", \"  \", \" # comment \"},\n\t\t\tpath:     \"file.txt\",\n\t\t\twant:     true,\n\t\t},\n\t\t\"carriage return handling\": {\n\t\t\tpatterns: []string{\"*.txt\\r\", \"*.md\\r\"},\n\t\t\tpath:     \"file.txt\",\n\t\t\twant:     true,\n\t\t},\n\t\t\"simple match\": {\n\t\t\tpatterns: []string{\"*.txt\"},\n\t\t\tpath:     \"file.txt\",\n\t\t\twant:     true,\n\t\t},\n\t\t\"no match\": {\n\t\t\tpatterns: []string{\"*.txt\"},\n\t\t\tpath:     \"file.go\",\n\t\t\twant:     false,\n\t\t},\n\t\t\"negated pattern\": {\n\t\t\tpatterns: []string{\"*.txt\", \"!test.txt\"},\n\t\t\tpath:     \"test.txt\",\n\t\t\twant:     false,\n\t\t},\n\t\t\"directory match\": {\n\t\t\tpatterns: []string{\"src/**/*.go\"},\n\t\t\tpath:     \"src/pkg/file.go\",\n\t\t\twant:     true,\n\t\t},\n\t\t\"escaped characters\": {\n\t\t\tpatterns: []string{\"\\\\#file.txt\"},\n\t\t\tpath:     \"#file.txt\",\n\t\t\twant:     true,\n\t\t},\n\t\t\"multiple patterns with override\": {\n\t\t\tpatterns: []string{\"*.txt\", \"!test.txt\", \"test.txt\"},\n\t\t\tpath:     \"test.txt\",\n\t\t\twant:     true,\n\t\t},\n\t\t\"directory trailing slash\": {\n\t\t\tpatterns: []string{\"logs/\"},\n\t\t\tpath:     \"logs/debug.log\",\n\t\t\twant:     true,\n\t\t},\n\t\t\"comment and empty lines\": {\n\t\t\tpatterns: []string{\"\", \"# comment\", \"*.txt\"},\n\t\t\tpath:     \"file.txt\",\n\t\t\twant:     true,\n\t\t},\n\t}\n\n\tfor name, tc := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tf := CompileFilterPatterns(tc.patterns...)\n\t\t\tgot := f.MatchesPath(tc.path)\n\t\t\tassert.Equal(t, got, tc.want, \"path: %q, patterns: %v\", tc.path, tc.patterns)\n\t\t})\n\t}\n}\n\nfunc TestMatchesPathHow(t *testing.T) {\n\ttests := map[string]struct {\n\t\tpatterns        []string\n\t\tpath            string\n\t\twantMatch       bool\n\t\twantMatchLine   string\n\t\twantMatchNegate bool\n\t}{\n\t\t\"matches first pattern\": {\n\t\t\tpatterns:        []string{\"*.txt\", \"*.go\"},\n\t\t\tpath:            \"file.txt\",\n\t\t\twantMatch:       true,\n\t\t\twantMatchLine:   \"*.txt\",\n\t\t\twantMatchNegate: false,\n\t\t},\n\t\t\"matches negated pattern\": {\n\t\t\tpatterns:        []string{\"*.txt\", \"!test.txt\"},\n\t\t\tpath:            \"test.txt\",\n\t\t\twantMatch:       false,\n\t\t\twantMatchLine:   \"!test.txt\",\n\t\t\twantMatchNegate: true,\n\t\t},\n\t\t\"no match returns nil pattern\": {\n\t\t\tpatterns:        []string{\"*.txt\"},\n\t\t\tpath:            \"file.go\",\n\t\t\twantMatch:       false,\n\t\t\twantMatchLine:   \"\",\n\t\t\twantMatchNegate: false,\n\t\t},\n\t}\n\n\tfor name, tc := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tf := CompileFilterPatterns(tc.patterns...)\n\t\t\tgotMatch, gotPattern := f.MatchesPathHow(tc.path)\n\n\t\t\tassert.Equal(t, tc.wantMatch, gotMatch)\n\n\t\t\tif tc.wantMatchLine == \"\" {\n\t\t\t\tassert.Nil(t, gotPattern)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tassert.NotNil(t, gotPattern)\n\t\t\tassert.Equal(t, tc.wantMatchLine, gotPattern.Line)\n\t\t\tassert.Equal(t, tc.wantMatchNegate, gotPattern.Negate)\n\t\t})\n\t}\n}\n\nfunc TestCompileAndMatchPatterns(t *testing.T) {\n\ttests := map[string]struct {\n\t\tpatterns    []string\n\t\tpathsToWant map[string]bool\n\t}{\n\t\t\"match all files\": {\n\t\t\tpatterns: []string{\"*\"},\n\t\t\tpathsToWant: map[string]bool{\n\t\t\t\t\"main.go\":              true,\n\t\t\t\t\"internal/util.go\":     true,\n\t\t\t\t\"src/main.go\":          true,\n\t\t\t\t\"src/internal/util.go\": true,\n\t\t\t\t\"README.md\":            true,\n\t\t\t\t\"internal/test.txt\":    true,\n\t\t\t},\n\t\t},\n\t\t\"match all files except top-level hidden files and directories\": {\n\t\t\tpatterns: []string{\"*\", \"!.*\"},\n\t\t\tpathsToWant: map[string]bool{\n\t\t\t\t\"main.go\":              true,\n\t\t\t\t\"internal/util.go\":     true,\n\t\t\t\t\"src/main.go\":          true,\n\t\t\t\t\"src/internal/util.go\": true,\n\t\t\t\t\"src/.env\":             true,\n\t\t\t\t\"README.md\":            true,\n\t\t\t\t\"internal/test.txt\":    true,\n\n\t\t\t\t\".git/config.txt\": false,\n\t\t\t\t\".env\":            false,\n\t\t\t},\n\t\t},\n\t\t\"match all files except recursive hidden files and directories\": {\n\t\t\tpatterns: []string{\"*\", \"!**/.*\"},\n\t\t\tpathsToWant: map[string]bool{\n\t\t\t\t\"main.go\":              true,\n\t\t\t\t\"internal/util.go\":     true,\n\t\t\t\t\"src/main.go\":          true,\n\t\t\t\t\"src/internal/util.go\": true,\n\t\t\t\t\"README.md\":            true,\n\t\t\t\t\"internal/test.txt\":    true,\n\n\t\t\t\t\"src/.env\":        false,\n\t\t\t\t\".git/config.txt\": false,\n\t\t\t\t\".env\":            false,\n\t\t\t},\n\t\t},\n\t\t\"match top-level go files\": {\n\t\t\tpatterns: []string{\"*.go\"},\n\t\t\tpathsToWant: map[string]bool{\n\t\t\t\t\"main.go\": true,\n\n\t\t\t\t\"internal/util.go\":     false,\n\t\t\t\t\"src/main.go\":          false,\n\t\t\t\t\"src/internal/util.go\": false,\n\t\t\t\t\"README.md\":            false,\n\t\t\t\t\"internal/test.txt\":    false,\n\t\t\t},\n\t\t},\n\t\t\"match go files recursively\": {\n\t\t\tpatterns: []string{\"**/*.go\"},\n\t\t\tpathsToWant: map[string]bool{\n\t\t\t\t\"main.go\":              true,\n\t\t\t\t\"internal/util.go\":     true,\n\t\t\t\t\"src/main.go\":          true,\n\t\t\t\t\"src/internal/util.go\": true,\n\n\t\t\t\t\"README.md\":         false,\n\t\t\t\t\"internal/test.txt\": false,\n\t\t\t},\n\t\t},\n\t\t\"match go files recursively with negation\": {\n\t\t\tpatterns: []string{\"**/*.go\", \"!internal/**\"},\n\t\t\tpathsToWant: map[string]bool{\n\t\t\t\t\"main.go\":              true,\n\t\t\t\t\"src/main.go\":          true,\n\t\t\t\t\"src/internal/util.go\": true,\n\n\t\t\t\t\"internal/util.go\":  false,\n\t\t\t\t\"README.md\":         false,\n\t\t\t\t\"internal/test.txt\": false,\n\t\t\t},\n\t\t},\n\t\t\"match with escaped special characters\": {\n\t\t\tpatterns: []string{`\\!important.txt`, `\\#comment.txt`},\n\t\t\tpathsToWant: map[string]bool{\n\t\t\t\t\"!important.txt\": true,\n\t\t\t\t\"#comment.txt\":   true,\n\n\t\t\t\t\"important.txt\":       false,\n\t\t\t\t\"comment.txt\":         false,\n\t\t\t\t\"test/!important.txt\": false,\n\t\t\t},\n\t\t},\n\t\t\"match directories with trailing slash\": {\n\t\t\tpatterns: []string{\"docs/\", \"!docs/internal/\"},\n\t\t\tpathsToWant: map[string]bool{\n\t\t\t\t\"docs/readme.md\":   true,\n\t\t\t\t\"docs/api/spec.md\": true,\n\n\t\t\t\t\"docs/internal/dev.md\":  false,\n\t\t\t\t\"docs/internal/arch.md\": false,\n\t\t\t\t\"other/docs/readme.md\":  false,\n\t\t\t},\n\t\t},\n\t\t\"match with directory depth constraints\": {\n\t\t\tpatterns: []string{\n\t\t\t\t\"/*/*.go\",    // Matches files exactly one directory deep\n\t\t\t\t\"!/**/test/\", // Excludes any test directories at any depth\n\t\t\t},\n\t\t\tpathsToWant: map[string]bool{\n\t\t\t\t\"cmd/main.go\":        true,\n\t\t\t\t\"internal/config.go\": true,\n\n\t\t\t\t\"main.go\":              false,\n\t\t\t\t\"pkg/sub/util.go\":      false,\n\t\t\t\t\"cmd/test/testutil.go\": false,\n\t\t\t},\n\t\t},\n\t\t\"recursively match subdirectory and extension\": {\n\t\t\tpatterns: []string{\"src/**/*.go\"},\n\t\t\tpathsToWant: map[string]bool{\n\t\t\t\t\"src/pkg/file.go\": true,\n\n\t\t\t\t\"cmd/main.go\":          false,\n\t\t\t\t\"internal/config.go\":   false,\n\t\t\t\t\"main.go\":              false,\n\t\t\t\t\"pkg/sub/util.go\":      false,\n\t\t\t\t\"cmd/test/testutil.go\": false,\n\t\t\t},\n\t\t},\n\t\t\"complex nested directory matching\": {\n\t\t\tpatterns: []string{\n\t\t\t\t\"src/*/test/**/*.go\",\n\t\t\t\t\"!src/*/test/vendor/**\",\n\t\t\t\t\"!src/temp/*/\",\n\t\t\t},\n\t\t\tpathsToWant: map[string]bool{\n\t\t\t\t\"src/project/test/unit/main_test.go\":      true,\n\t\t\t\t\"src/lib/test/integration/helper_test.go\": true,\n\n\t\t\t\t\"src/project/test/vendor/mock/mock.go\": false,\n\t\t\t\t\"src/temp/cache/data.txt\":              false,\n\t\t\t\t\"src/project/prod/main.go\":             false,\n\t\t\t},\n\t\t},\n\t\t\"match with multiple pattern ordering\": {\n\t\t\tpatterns: []string{\n\t\t\t\t\"*.txt\",\n\t\t\t\t\"!important.txt\",\n\t\t\t\t\"!!important.txt\",\n\t\t\t\t\"!test/important.txt\",\n\t\t\t},\n\t\t\tpathsToWant: map[string]bool{\n\t\t\t\t\"readme.txt\":         true,\n\t\t\t\t\"important.txt\":      true,\n\t\t\t\t\"docs/notes.txt\":     false,\n\t\t\t\t\"test/important.txt\": false,\n\t\t\t},\n\t\t},\n\t\t\"match with question mark wildcards\": {\n\t\t\tpatterns: []string{\"test?.txt\", \"lib/????.go\"},\n\t\t\tpathsToWant: map[string]bool{\n\t\t\t\t\"test1.txt\":   true,\n\t\t\t\t\"testa.txt\":   true,\n\t\t\t\t\"lib/util.go\": true,\n\t\t\t\t\"lib/main.go\": true,\n\n\t\t\t\t\"test.txt\":     false,\n\t\t\t\t\"test12.txt\":   false,\n\t\t\t\t\"lib/utils.go\": false,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tt := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tf := CompileFilterPatterns(tt.patterns...)\n\n\t\t\tfor path, want := range tt.pathsToWant {\n\t\t\t\tgot := f.MatchesPath(path)\n\t\t\t\tassert.Equal(t, want, got, \"Patterns: %q; Path: %q\", strings.Join(tt.patterns, \", \"), path)\n\t\t\t}\n\t\t})\n\t}\n}\n"
    },
    {
      "path": "amalgo/testdir/file1.go",
      "content": "package main\n\nfunc main() {}\n"
    },
    {
      "path": "amalgo/testdir/sub/file2.go",
      "content": "package sub\n\nfunc Helper() {}\n"
    }
  ],
  "outlines": [
    {
      "path": "amalgo/internal/output.go",
      "symbols": [
        {
          "type": "type",
          "name": "OutputFormat",
          "metadata": null
        },
        {
          "type": "const",
          "name": "OutputFormatDefault",
          "metadata": null
        },
        {
          "type": "const",
          "name": "OutputFormatJSON",
          "metadata": null
        },
        {
          "type": "struct",
          "name": "OutputOptions",
          "documentation": "Options configures the output generation\n",
          "children": [
            {
              "type": "field",
              "name": "NoTree",
              "signature": "bool",
              "metadata": null
            },
            {
              "type": "field",
              "name": "NoDump",
              "signature": "bool",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Outline",
              "signature": "bool",
              "metadata": null
            },
            {
              "type": "field",
              "name": "SkipBinary",
              "signature": "bool",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Format",
              "signature": "OutputFormat",
              "metadata": null
            }
          ],
          "metadata": null
        },
        {
          "type": "function",
          "name": "GenerateOutput",
          "signature": "func GenerateOutput(paths []PathInfo, registry *parser.Registry, opts OutputOptions) (string, error)",
          "documentation": "GenerateOutput creates the complete output string\n",
          "metadata": null
        },
        {
          "type": "function",
          "name": "generateOutlines",
          "signature": "func generateOutlines(paths []PathInfo, registry *parser.Registry) (string, error)",
          "metadata": null
        },
        {
          "type": "function",
          "name": "processFileOutline",
          "signature": "func processFileOutline(filePath string, registry *parser.Registry) (string, error)",
          "metadata": null
        },
        {
          "type": "function",
          "name": "writeSymbols",
          "signature": "func writeSymbols(symbols []*parser.Symbol, depth int) (string, error)",
          "metadata": null
        },
        {
          "type": "function",
          "name": "dumpFiles",
          "signature": "func dumpFiles(paths []PathInfo, skipBinary bool) (string, error)",
          "metadata": null
        }
      ]
    },
    {
      "path": "amalgo/internal/output_json.go",
      "symbols": [
        {
          "type": "struct",
          "name": "JSONDocument",
          "children": [
            {
              "type": "field",
              "name": "Timestamp",
              "signature": "string",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Tree",
              "signature": "string",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Files",
              "signature": "[]JSONFile",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Outlines",
              "signature": "[]JSONFileOutline",
              "metadata": null
            }
          ],
          "metadata": null
        },
        {
          "type": "struct",
          "name": "JSONFile",
          "children": [
            {
              "type": "field",
              "name": "Path",
              "signature": "string",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Content",
              "signature": "string",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Binary",
              "signature": "bool",
              "metadata": null
            }
          ],
          "metadata": null
        },
        {
          "type": "struct",
          "name": "JSONFileOutline",
          "documentation": "JSONFileOutline represents the parsed structure of a source file\n",
          "children": [
            {
              "type": "field",
              "name": "Path",
              "signature": "string",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Symbols",
              "signature": "[]JSONSymbol",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Errors",
              "signature": "[]string",
              "metadata": null
            }
          ],
          "metadata": null
        },
        {
          "type": "struct",
          "name": "JSONSymbol",
          "documentation": "JSONSymbol represents a parsed symbol (function, type, class, etc.)\n",
          "children": [
            {
              "type": "field",
              "name": "Type",
              "signature": "string",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Name",
              "signature": "string",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Signature",
              "signature": "string",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Documentation",
              "signature": "string",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Decorators",
              "signature": "[]string",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Children",
              "signature": "[]JSONSymbol",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Metadata",
              "signature": "any",
              "metadata": null
            }
          ],
          "metadata": null
        },
        {
          "type": "function",
          "name": "generateOutputJSON",
          "signature": "func generateOutputJSON(paths []PathInfo, registry *parser.Registry, opts OutputOptions) (string, error)",
          "metadata": null
        },
        {
          "type": "function",
          "name": "generateFilesJSON",
          "signature": "func generateFilesJSON(paths []PathInfo, skipBinary bool) ([]JSONFile, error)",
          "metadata": null
        },
        {
          "type": "function",
          "name": "generateOutlinesJSON",
          "signature": "func generateOutlinesJSON(paths []PathInfo, registry *parser.Registry) ([]JSONFileOutline, error)",
          "metadata": null
        },
        {
          "type": "function",
          "name": "convertSymbol",
          "signature": "func convertSymbol(ps *parser.Symbol) (JSONSymbol, error)",
          "metadata": null
        }
      ]
    },
    {
      "path": "amalgo/internal/parser/golang.go",
      "symbols": [
        {
          "type": "struct",
          "name": "GoParser",
          "documentation": "GoParser implements Parser for Go source files\n",
          "metadata": null
        },
        {
          "type": "function",
          "name": "NewGoParser",
          "signature": "func NewGoParser() *GoParser",
          "documentation": "NewGoParser creates a new Go parser\n",
          "metadata": null
        },
        {
          "type": "method",
          "name": "*GoParser.Extensions",
          "signature": "func (p *GoParser) Extensions() []string",
          "metadata": null
        },
        {
          "type": "method",
          "name": "*GoParser.Parse",
          "signature": "func (p *GoParser) Parse(content []byte, filename string) (*FileOutline, error)",
          "metadata": null
        },
        {
          "type": "method",
          "name": "*GoParser.processDecl",
          "signature": "func (p *GoParser) processDecl(decl ast.Decl, file *ast.File) []*Symbol",
          "metadata": null
        },
        {
          "type": "method",
          "name": "*GoParser.processInterface",
          "signature": "func (p *GoParser) processInterface(iface *ast.InterfaceType) []*Symbol",
          "metadata": null
        },
        {
          "type": "method",
          "name": "*GoParser.processStruct",
          "signature": "func (p *GoParser) processStruct(structType *ast.StructType) []*Symbol",
          "metadata": null
        },
        {
          "type": "method",
          "name": "*GoParser.getFunctionSignature",
          "signature": "func (p *GoParser) getFunctionSignature(fn *ast.FuncDecl) string",
          "metadata": null
        },
        {
          "type": "method",
          "name": "*GoParser.getFuncTypeSignature",
          "signature": "func (p *GoParser) getFuncTypeSignature(ft *ast.FuncType) string",
          "metadata": null
        },
        {
          "type": "method",
          "name": "*GoParser.typeToString",
          "signature": "func (p *GoParser) typeToString(expr ast.Expr) string",
          "metadata": null
        },
        {
          "type": "method",
          "name": "*GoParser.getTypeSymbolType",
          "signature": "func (p *GoParser) getTypeSymbolType(typeSpec *ast.TypeSpec) string",
          "metadata": null
        },
        {
          "type": "method",
          "name": "*GoParser.getDocstring",
          "signature": "func (p *GoParser) getDocstring(doc *ast.CommentGroup) string",
          "metadata": null
        }
      ]
    },
    {
      "path": "amalgo/internal/parser/parser.go",
      "symbols": [
        {
          "type": "interface",
          "name": "Parser",
          "documentation": "Parser defines the interface for language-specific parsers\n",
          "children": [
            {
              "type": "method",
              "name": "Parse",
              "signature": "(content []byte, filename string) (*FileOutline, error)",
              "documentation": "Parse analyzes the content of a file and returns a structured outline\n",
              "metadata": null
            },
            {
              "type": "method",
              "name": "Extensions",
              "signature": "() []string",
              "documentation": "Extensions returns the file extensions this parser handles\n",
              "metadata": null
            }
          ],
          "metadata": null
        },
        {
          "type": "struct",
          "name": "Symbol",
          "documentation": "Symbol represents a parsed symbol (function, type, class, etc.)\n",
          "children": [
            {
              "type": "field",
              "name": "Type",
              "signature": "string",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Name",
              "signature": "string",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Signature",
              "signature": "string",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Docstring",
              "signature": "string",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Decorators",
              "signature": "[]string",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Children",
              "signature": "[]*Symbol",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Metadata",
              "signature": "map[string]any",
              "metadata": null
            }
          ],
          "metadata": null
        },
        {
          "type": "struct",
          "name": "FileOutline",
          "documentation": "FileOutline represents the parsed structure of a source file\n",
          "children": [
            {
              "type": "field",
              "name": "Filename",
              "signature": "string",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Symbols",
              "signature": "[]*Symbol",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Errors",
              "signature": "[]error",
              "metadata": null
            }
          ],
          "metadata": null
        },
        {
          "type": "struct",
          "name": "Registry",
          "documentation": "Registry manages the available parsers\n",
          "children": [
            {
              "type": "field",
              "name": "parsers",
              "signature": "map[string]Parser",
              "metadata": null
            }
          ],
          "metadata": null
        },
        {
          "type": "function",
          "name": "NewRegistry",
          "signature": "func NewRegistry() *Registry",
          "documentation": "NewRegistry creates a new parser registry\n",
          "metadata": null
        },
        {
          "type": "method",
          "name": "*Registry.Register",
          "signature": "func (r *Registry) Register(parser Parser)",
          "documentation": "Register adds a parser to the registry\n",
          "metadata": null
        },
        {
          "type": "method",
          "name": "*Registry.GetParser",
          "signature": "func (r *Registry) GetParser(filename string) Parser",
          "documentation": "GetParser returns the appropriate parser for a file extension\n",
          "metadata": null
        },
        {
          "type": "method",
          "name": "*Registry.IsSupported",
          "signature": "func (r *Registry) IsSupported(filename string) bool",
          "documentation": "IsSupported checks if there's a parser available for the given file extension\n",
          "metadata": null
        }
      ]
    },
    {
      "path": "amalgo/internal/traverse.go",
      "symbols": [
        {
          "type": "struct",
          "name": "PathInfo",
          "documentation": "PathInfo represents information about a file or directory\n",
          "children": [
            {
              "type": "field",
              "name": "Path",
              "signature": "string",
              "metadata": null
            },
            {
              "type": "field",
              "name": "RelativePath",
              "signature": "string",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Depth",
              "signature": "int",
              "metadata": null
            },
            {
              "type": "field",
              "name": "IsDir",
              "signature": "bool",
              "metadata": null
            }
          ],
          "metadata": null
        },
        {
          "type": "function",
          "name": "TraverseDirectory",
          "signature": "func TraverseDirectory(dir string, filterPatterns []string) ([]PathInfo, error)",
          "documentation": "TraverseDirectory traverses the directory and collects path information using the filter package\n",
          "metadata": null
        },
        {
          "type": "function",
          "name": "processPaths",
          "signature": "func processPaths(paths *[]PathInfo) error",
          "documentation": "ProcessPaths adds all parent directory paths to the given slice of PathInfo.\nThe function modifies the input slice in place, adding parent directories in order\nfrom shallowest to deepest, followed by the original paths.\n",
          "metadata": null
        }
      ]
    },
    {
      "path": "amalgo/internal/traverse_test.go",
      "symbols": [
        {
          "type": "function",
          "name": "TestTraverseDirectories",
          "signature": "func TestTraverseDirectories(t *testing.T)",
          "metadata": null
        },
        {
          "type": "function",
          "name": "TestProcessPaths",
          "signature": "func TestProcessPaths(t *testing.T)",
          "metadata": null
        }
      ]
    },
    {
      "path": "amalgo/internal/utils.go",
      "symbols": [
        {
          "type": "function",
          "name": "IsBinaryFile",
          "signature": "func IsBinaryFile(path string) (bool, error)",
          "documentation": "IsBinaryFile determines if a file is binary by checking its contents\n",
          "metadata": null
        },
        {
          "type": "function",
          "name": "GenerateTree",
          "signature": "func GenerateTree(paths []PathInfo) string",
          "documentation": "GenerateTree creates a textual representation of the directory structure\n",
          "metadata": null
        },
        {
          "type": "function",
          "name": "WriteOutput",
          "signature": "func WriteOutput(path string, content string) error",
          "documentation": "WriteOutput writes content to a file or stdout\n",
          "metadata": null
        },
        {
          "type": "function",
          "name": "FormatTimestamp",
          "signature": "func FormatTimestamp() string",
          "documentation": "FormatTimestamp returns a formatted timestamp string\n",
          "metadata": null
        }
      ]
    },
    {
      "path": "amalgo/main.go",
      "symbols": [
        {
          "type": "const",
          "name": "appName",
          "metadata": null
        },
        {
          "type": "const",
          "name": "version",
          "metadata": null
        },
        {
          "type": "function",
          "name": "main",
          "signature": "func main()",
          "metadata": null
        },
        {
          "type": "function",
          "name": "run",
          "signature": "func run() int",
          "metadata": null
        },
        {
          "type": "struct",
          "name": "RootCmd",
          "children": [
            {
              "type": "field",
              "name": "Dir",
              "signature": "string",
              "documentation": "Default command args and flags\n",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Output",
              "signature": "string",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Stdout",
              "signature": "bool",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Filter",
              "signature": "[]string",
              "metadata": null
            },
            {
              "type": "field",
              "name": "NoTree",
              "signature": "bool",
              "metadata": null
            },
            {
              "type": "field",
              "name": "NoDump",
              "signature": "bool",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Outline",
              "signature": "bool",
              "metadata": null
            },
            {
              "type": "field",
              "name": "NoColor",
              "signature": "bool",
              "metadata": null
            },
            {
              "type": "field",
              "name": "IncludeBinary",
              "signature": "bool",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Format",
              "signature": "internal.OutputFormat",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Version",
              "signature": "versionFlag",
              "documentation": "Subcommands\n",
              "metadata": null
            }
          ],
          "metadata": null
        },
        {
          "type": "method",
          "name": "*RootCmd.validate",
          "signature": "func (c *RootCmd) validate() bool",
          "metadata": null
        },
        {
          "type": "method",
          "name": "*RootCmd.Run",
          "signature": "func (c *RootCmd) Run() error",
          "metadata": null
        },
        {
          "type": "type",
          "name": "versionFlag",
          "metadata": null
        },
        {
          "type": "method",
          "name": "versionFlag.Decode",
          "signature": "func (v versionFlag) Decode(_ *kong.DecodeContext) error",
          "metadata": null
        },
        {
          "type": "method",
          "name": "versionFlag.IsBool",
          "signature": "func (v versionFlag) IsBool() bool",
          "metadata": null
        },
        {
          "type": "method",
          "name": "versionFlag.BeforeApply",
          "signature": "func (v versionFlag) BeforeApply(app *kong.Kong, vars kong.Vars) error",
          "metadata": null
        },
        {
          "type": "struct",
          "name": "exitWriter",
          "documentation": "Custom writer that can capture output for testing\n",
          "children": [
            {
              "type": "field",
              "name": "code",
              "signature": "int",
              "metadata": null
            },
            {
              "type": "field",
              "name": "message",
              "signature": "string",
              "metadata": null
            }
          ],
          "metadata": null
        },
        {
          "type": "method",
          "name": "*exitWriter.Write",
          "signature": "func (w *exitWriter) Write(p []byte) (n int, err error)",
          "metadata": null
        },
        {
          "type": "method",
          "name": "*exitWriter.Exit",
          "signature": "func (w *exitWriter) Exit(code int)",
          "metadata": null
        }
      ]
    },
    {
      "path": "amalgo/main_test.go",
      "symbols": [
        {
          "type": "function",
          "name": "TestMain",
          "signature": "func TestMain(m *testing.M)",
          "metadata": null
        },
        {
          "type": "function",
          "name": "TestScript",
          "signature": "func TestScript(t *testing.T)",
          "metadata": null
        },
        {
          "type": "function",
          "name": "compareFiles",
          "signature": "func compareFiles(ts *testscript.TestScript, neg bool, args []string)",
          "metadata": null
        },
        {
          "type": "function",
          "name": "createDiff",
          "signature": "func createDiff(name1, name2, text1, text2 string) string",
          "metadata": null
        }
      ]
    },
    {
      "path": "amalgo/pkg/filter/filter.go",
      "symbols": [
        {
          "type": "struct",
          "name": "Filterer",
          "documentation": "Filterer wraps a list of filter patterns.\n",
          "children": [
            {
              "type": "field",
              "name": "patterns",
              "signature": "[]*Pattern",
              "metadata": null
            }
          ],
          "metadata": null
        },
        {
          "type": "struct",
          "name": "Pattern",
          "documentation": "Pattern encapsulates a regexp pattern and whether it is negated.\n",
          "children": [
            {
              "type": "field",
              "name": "Pattern",
              "signature": "*regexp.Regexp",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Negate",
              "signature": "bool",
              "metadata": null
            },
            {
              "type": "field",
              "name": "LineNo",
              "signature": "int",
              "metadata": null
            },
            {
              "type": "field",
              "name": "Line",
              "signature": "string",
              "metadata": null
            }
          ],
          "metadata": null
        },
        {
          "type": "method",
          "name": "*Filterer.MatchesPath",
          "signature": "func (f *Filterer) MatchesPath(path string) bool",
          "documentation": "MatchesPath returns true if the path matches the patterns.\n",
          "metadata": null
        },
        {
          "type": "method",
          "name": "*Filterer.MatchesPathHow",
          "signature": "func (f *Filterer) MatchesPathHow(path string) (bool, *Pattern)",
          "documentation": "MatchesPathHow returns whether the path matches and which pattern matched it.\n",
          "metadata": null
        },
        {
          "type": "function",
          "name": "CompileFilterPatterns",
          "signature": "func CompileFilterPatterns(patterns ...string) *Filterer",
          "documentation": "CompileFilterPatterns accepts a variadic set of strings and returns a Filterer\ninstance with the compiled patterns.\n",
          "metadata": null
        },
        {
          "type": "function",
          "name": "CompileFilterPatternFile",
          "signature": "func CompileFilterPatternFile(path string) (*Filterer, error)",
          "documentation": "CompileFilterPatternFile reads patterns from a file and compiles them.\n",
          "metadata": null
        },
        {
          "type": "function",
          "name": "CompileFilterPatternFileAndLines",
          "signature": "func CompileFilterPatternFileAndLines(path string, lines ...string) (*Filterer, error)",
          "documentation": "CompileExcludePatternFileAndLines compiles patterns from both a file and additional lines.\n",
          "metadata": null
        },
        {
          "type": "function",
          "name": "getPatternFromLine",
          "signature": "func getPatternFromLine(line string) (*regexp.Regexp, bool)",
          "documentation": "getPatternFromLine converts a single pattern line into a regexp and bool indicating\nif it's a negated pattern. The rules follow .gitignore syntax.\n",
          "metadata": null
        }
      ]
    },
    {
      "path": "amalgo/pkg/filter/filter_test.go",
      "symbols": [
        {
          "type": "function",
          "name": "TestMatchesPath",
          "signature": "func TestMatchesPath(t *testing.T)",
          "metadata": null
        },
        {
          "type": "function",
          "name": "TestMatchesPathHow",
          "signature": "func TestMatchesPathHow(t *testing.T)",
          "metadata": null
        },
        {
          "type": "function",
          "name": "TestCompileAndMatchPatterns",
          "signature": "func TestCompileAndMatchPatterns(t *testing.T)",
          "metadata": null
        }
      ]
    },
    {
      "path": "amalgo/testdir/file1.go",
      "symbols": [
        {
          "type": "function",
          "name": "main",
          "signature": "func main()",
          "metadata": null
        }
      ]
    },
    {
      "path": "amalgo/testdir/sub/file2.go",
      "symbols": [
        {
          "type": "function",
          "name": "Helper",
          "signature": "func Helper()",
          "metadata": null
        }
      ]
    }
  ]
}