## Generated with Amalgo at: 2025-01-14 23:07:40

## File Tree

└── amalgo/
    ├── main.go
    ├── main_test.go
    ├── internal/
    │   ├── output.go
    │   ├── output_json.go
    │   ├── traverse.go
    │   ├── traverse_test.go
    │   ├── utils.go
    │   └── parser/
    │       ├── golang.go
    │       └── parser.go
    ├── pkg/
    │   └── filter/
    │       ├── filter.go
    │       └── filter_test.go
    └── testdir/
        ├── file1.go
        └── sub/
            └── file2.go

## Language-Specific Outlines

### File: amalgo/internal/output.go

TYPE: OutputFormat
CONST: OutputFormatDefault
CONST: OutputFormatJSON
STRUCT: OutputOptions
  Documentation:
    Options configures the output generation
  FIELD: NoTree (bool)
  FIELD: NoDump (bool)
  FIELD: Outline (bool)
  FIELD: SkipBinary (bool)
  FIELD: Format (OutputFormat)
FUNCTION: GenerateOutput (func GenerateOutput(paths []PathInfo, registry *parser.Registry, opts OutputOptions) (string, error))
  Documentation:
    GenerateOutput creates the complete output string
FUNCTION: generateOutlines (func generateOutlines(paths []PathInfo, registry *parser.Registry) (string, error))
FUNCTION: processFileOutline (func processFileOutline(filePath string, registry *parser.Registry) (string, error))
FUNCTION: writeSymbols (func writeSymbols(symbols []*parser.Symbol, depth int) (string, error))
FUNCTION: dumpFiles (func dumpFiles(paths []PathInfo, skipBinary bool) (string, error))

### File: amalgo/internal/output_json.go

STRUCT: JSONDocument
  FIELD: Timestamp (string)
  FIELD: Tree (string)
  FIELD: Files ([]JSONFile)
  FIELD: Outlines ([]JSONFileOutline)
STRUCT: JSONFile
  FIELD: Path (string)
  FIELD: Content (string)
  FIELD: Binary (bool)
STRUCT: JSONFileOutline
  Documentation:
    JSONFileOutline represents the parsed structure of a source file
  FIELD: Path (string)
  FIELD: Symbols ([]JSONSymbol)
  FIELD: Errors ([]string)
STRUCT: JSONSymbol
  Documentation:
    JSONSymbol represents a parsed symbol (function, type, class, etc.)
  FIELD: Type (string)
  FIELD: Name (string)
  FIELD: Signature (string)
  FIELD: Documentation (string)
  FIELD: Decorators ([]string)
  FIELD: Children ([]JSONSymbol)
  FIELD: Metadata (any)
FUNCTION: generateOutputJSON (func generateOutputJSON(paths []PathInfo, registry *parser.Registry, opts OutputOptions) (string, error))
FUNCTION: generateFilesJSON (func generateFilesJSON(paths []PathInfo, skipBinary bool) ([]JSONFile, error))
FUNCTION: generateOutlinesJSON (func generateOutlinesJSON(paths []PathInfo, registry *parser.Registry) ([]JSONFileOutline, error))
FUNCTION: convertSymbol (func convertSymbol(ps *parser.Symbol) (JSONSymbol, error))

### File: amalgo/internal/parser/golang.go

STRUCT: GoParser
  Documentation:
    GoParser implements Parser for Go source files
FUNCTION: NewGoParser (func NewGoParser() *GoParser)
  Documentation:
    NewGoParser creates a new Go parser
METHOD: *GoParser.Extensions (func (p *GoParser) Extensions() []string)
METHOD: *GoParser.Parse (func (p *GoParser) Parse(content []byte, filename string) (*FileOutline, error))
METHOD: *GoParser.processDecl (func (p *GoParser) processDecl(decl ast.Decl, file *ast.File) []*Symbol)
METHOD: *GoParser.processInterface (func (p *GoParser) processInterface(iface *ast.InterfaceType) []*Symbol)
METHOD: *GoParser.processStruct (func (p *GoParser) processStruct(structType *ast.StructType) []*Symbol)
METHOD: *GoParser.getFunctionSignature (func (p *GoParser) getFunctionSignature(fn *ast.FuncDecl) string)
METHOD: *GoParser.getFuncTypeSignature (func (p *GoParser) getFuncTypeSignature(ft *ast.FuncType) string)
METHOD: *GoParser.typeToString (func (p *GoParser) typeToString(expr ast.Expr) string)
METHOD: *GoParser.getTypeSymbolType (func (p *GoParser) getTypeSymbolType(typeSpec *ast.TypeSpec) string)
METHOD: *GoParser.getDocstring (func (p *GoParser) getDocstring(doc *ast.CommentGroup) string)

### File: amalgo/internal/parser/parser.go

INTERFACE: Parser
  Documentation:
    Parser defines the interface for language-specific parsers
  METHOD: Parse ((content []byte, filename string) (*FileOutline, error))
    Documentation:
      Parse analyzes the content of a file and returns a structured outline
  METHOD: Extensions (() []string)
    Documentation:
      Extensions returns the file extensions this parser handles
STRUCT: Symbol
  Documentation:
    Symbol represents a parsed symbol (function, type, class, etc.)
  FIELD: Type (string)
  FIELD: Name (string)
  FIELD: Signature (string)
  FIELD: Docstring (string)
  FIELD: Decorators ([]string)
  FIELD: Children ([]*Symbol)
  FIELD: Metadata (map[string]any)
STRUCT: FileOutline
  Documentation:
    FileOutline represents the parsed structure of a source file
  FIELD: Filename (string)
  FIELD: Symbols ([]*Symbol)
  FIELD: Errors ([]error)
STRUCT: Registry
  Documentation:
    Registry manages the available parsers
  FIELD: parsers (map[string]Parser)
FUNCTION: NewRegistry (func NewRegistry() *Registry)
  Documentation:
    NewRegistry creates a new parser registry
METHOD: *Registry.Register (func (r *Registry) Register(parser Parser))
  Documentation:
    Register adds a parser to the registry
METHOD: *Registry.GetParser (func (r *Registry) GetParser(filename string) Parser)
  Documentation:
    GetParser returns the appropriate parser for a file extension
METHOD: *Registry.IsSupported (func (r *Registry) IsSupported(filename string) bool)
  Documentation:
    IsSupported checks if there's a parser available for the given file extension

### File: amalgo/internal/traverse.go

STRUCT: PathInfo
  Documentation:
    PathInfo represents information about a file or directory
  FIELD: Path (string)
  FIELD: RelativePath (string)
  FIELD: Depth (int)
  FIELD: IsDir (bool)
FUNCTION: TraverseDirectory (func TraverseDirectory(dir string, filterPatterns []string) ([]PathInfo, error))
  Documentation:
    TraverseDirectory traverses the directory and collects path information using the filter package
FUNCTION: processPaths (func processPaths(paths *[]PathInfo) error)
  Documentation:
    ProcessPaths adds all parent directory paths to the given slice of PathInfo.
    The function modifies the input slice in place, adding parent directories in order
    from shallowest to deepest, followed by the original paths.

### File: amalgo/internal/traverse_test.go

FUNCTION: TestTraverseDirectories (func TestTraverseDirectories(t *testing.T))
FUNCTION: TestProcessPaths (func TestProcessPaths(t *testing.T))

### File: amalgo/internal/utils.go

FUNCTION: IsBinaryFile (func IsBinaryFile(path string) (bool, error))
  Documentation:
    IsBinaryFile determines if a file is binary by checking its contents
FUNCTION: GenerateTree (func GenerateTree(paths []PathInfo) string)
  Documentation:
    GenerateTree creates a textual representation of the directory structure
FUNCTION: WriteOutput (func WriteOutput(path string, content string) error)
  Documentation:
    WriteOutput writes content to a file or stdout
FUNCTION: FormatTimestamp (func FormatTimestamp() string)
  Documentation:
    FormatTimestamp returns a formatted timestamp string

### File: amalgo/main.go

CONST: appName
CONST: version
FUNCTION: main (func main())
FUNCTION: run (func run() int)
STRUCT: RootCmd
  FIELD: Dir (string)
    Documentation:
      Default command args and flags
  FIELD: Output (string)
  FIELD: Stdout (bool)
  FIELD: Filter ([]string)
  FIELD: NoTree (bool)
  FIELD: NoDump (bool)
  FIELD: Outline (bool)
  FIELD: NoColor (bool)
  FIELD: IncludeBinary (bool)
  FIELD: Format (internal.OutputFormat)
  FIELD: Version (versionFlag)
    Documentation:
      Subcommands
METHOD: *RootCmd.validate (func (c *RootCmd) validate() bool)
METHOD: *RootCmd.Run (func (c *RootCmd) Run() error)
TYPE: versionFlag
METHOD: versionFlag.Decode (func (v versionFlag) Decode(_ *kong.DecodeContext) error)
METHOD: versionFlag.IsBool (func (v versionFlag) IsBool() bool)
METHOD: versionFlag.BeforeApply (func (v versionFlag) BeforeApply(app *kong.Kong, vars kong.Vars) error)
STRUCT: exitWriter
  Documentation:
    Custom writer that can capture output for testing
  FIELD: code (int)
  FIELD: message (string)
METHOD: *exitWriter.Write (func (w *exitWriter) Write(p []byte) (n int, err error))
METHOD: *exitWriter.Exit (func (w *exitWriter) Exit(code int))

### File: amalgo/main_test.go

FUNCTION: TestMain (func TestMain(m *testing.M))
FUNCTION: TestScript (func TestScript(t *testing.T))
FUNCTION: compareFiles (func compareFiles(ts *testscript.TestScript, neg bool, args []string))
FUNCTION: createDiff (func createDiff(name1, name2, text1, text2 string) string)

### File: amalgo/pkg/filter/filter.go

STRUCT: Filterer
  Documentation:
    Filterer wraps a list of filter patterns.
  FIELD: patterns ([]*Pattern)
STRUCT: Pattern
  Documentation:
    Pattern encapsulates a regexp pattern and whether it is negated.
  FIELD: Pattern (*regexp.Regexp)
  FIELD: Negate (bool)
  FIELD: LineNo (int)
  FIELD: Line (string)
METHOD: *Filterer.MatchesPath (func (f *Filterer) MatchesPath(path string) bool)
  Documentation:
    MatchesPath returns true if the path matches the patterns.
METHOD: *Filterer.MatchesPathHow (func (f *Filterer) MatchesPathHow(path string) (bool, *Pattern))
  Documentation:
    MatchesPathHow returns whether the path matches and which pattern matched it.
FUNCTION: CompileFilterPatterns (func CompileFilterPatterns(patterns ...string) *Filterer)
  Documentation:
    CompileFilterPatterns accepts a variadic set of strings and returns a Filterer
    instance with the compiled patterns.
FUNCTION: CompileFilterPatternFile (func CompileFilterPatternFile(path string) (*Filterer, error))
  Documentation:
    CompileFilterPatternFile reads patterns from a file and compiles them.
FUNCTION: CompileFilterPatternFileAndLines (func CompileFilterPatternFileAndLines(path string, lines ...string) (*Filterer, error))
  Documentation:
    CompileExcludePatternFileAndLines compiles patterns from both a file and additional lines.
FUNCTION: getPatternFromLine (func getPatternFromLine(line string) (*regexp.Regexp, bool))
  Documentation:
    getPatternFromLine converts a single pattern line into a regexp and bool indicating
    if it's a negated pattern. The rules follow .gitignore syntax.

### File: amalgo/pkg/filter/filter_test.go

FUNCTION: TestMatchesPath (func TestMatchesPath(t *testing.T))
FUNCTION: TestMatchesPathHow (func TestMatchesPathHow(t *testing.T))
FUNCTION: TestCompileAndMatchPatterns (func TestCompileAndMatchPatterns(t *testing.T))

### File: amalgo/testdir/file1.go

FUNCTION: main (func main())

### File: amalgo/testdir/sub/file2.go

FUNCTION: Helper (func Helper())

## File Contents

--- Start File: amalgo/internal/output.go
package internal

import (
	"fmt"
	"os"
	"strings"

	"github.com/Broderick-Westrope/amalgo/internal/parser"
)

type OutputFormat string

const (
	OutputFormatDefault = "default"
	OutputFormatJSON    = "json"
)

// Options configures the output generation
type OutputOptions struct {
	NoTree     bool
	NoDump     bool
	Outline    bool
	SkipBinary bool
	Format     OutputFormat
}

// GenerateOutput creates the complete output string
func GenerateOutput(paths []PathInfo, registry *parser.Registry, opts OutputOptions) (string, error) {
	if opts.Format == OutputFormatJSON {
		return generateOutputJSON(paths, registry, opts)
	}

	output := fmt.Sprintf("## Generated with Amalgo at: %s\n\n", FormatTimestamp())

	if !opts.NoTree {
		output += fmt.Sprintf("## File Tree\n\n%s\n", GenerateTree(paths))
	}

	if opts.Outline {
		outlines, err := generateOutlines(paths, registry)
		if err != nil {
			return "", fmt.Errorf("generating outlines: %w", err)
		}
		output += outlines
	}

	if !opts.NoDump {
		filesDump, err := dumpFiles(paths, opts.SkipBinary)
		if err != nil {
			return "", fmt.Errorf("dumping files: %w", err)
		}
		output += filesDump
	}
	return output, nil
}

func generateOutlines(paths []PathInfo, registry *parser.Registry) (string, error) {
	output := "## Language-Specific Outlines\n\n"

	var temp string
	var err error
	for _, path := range paths {
		if path.IsDir {
			continue
		}

		// Skip if no parser available for this file type
		if !registry.IsSupported(path.Path) {
			continue
		}

		temp, err = processFileOutline(path.Path, registry)
		if err != nil {
			return "", fmt.Errorf("processing outline for %q: %w", path.Path, err)
		}
		output += fmt.Sprintf("### File: %s\n\n%s\n", path.RelativePath, temp)
	}
	return output, nil
}

func processFileOutline(filePath string, registry *parser.Registry) (string, error) {
	content, err := os.ReadFile(filePath)
	if err != nil {
		return "", fmt.Errorf("reading file: %w", err)
	}

	parser := registry.GetParser(filePath)
	if parser == nil {
		return "", fmt.Errorf("no parser found for %q", filePath)
	}

	outline, err := parser.Parse(content, filePath)
	if err != nil {
		return "", fmt.Errorf("parsing file %q: %w", filePath, err)
	}

	if len(outline.Errors) > 0 {
		var errMsgs []string
		for _, err := range outline.Errors {
			errMsgs = append(errMsgs, err.Error())
		}
		return fmt.Sprintf("Parsing errors:\n%s\n", strings.Join(errMsgs, "\n")), nil
	}

	result, err := writeSymbols(outline.Symbols, 0)
	if err != nil {
		return "", fmt.Errorf("writing symbols: %w", err)
	}
	return result, nil
}

func writeSymbols(symbols []*parser.Symbol, depth int) (string, error) {
	indent := strings.Repeat("  ", depth)
	var output string
	for _, symbol := range symbols {
		// Write symbol header
		output += fmt.Sprintf("%s%s: %s", indent, strings.ToUpper(symbol.Type), symbol.Name)
		if symbol.Signature != "" {
			output += fmt.Sprintf(" (%s)", symbol.Signature)
		}
		output += "\n"

		// Write decorators if present
		if len(symbol.Decorators) > 0 {
			output += fmt.Sprintf("%s  Decorators: %s\n", indent, strings.Join(symbol.Decorators, ", "))
		}

		// Write docstring if present
		if symbol.Docstring != "" {
			docLines := strings.Split(strings.TrimSpace(symbol.Docstring), "\n")
			output += fmt.Sprintf("%s  Documentation:\n", indent)
			for _, line := range docLines {
				output += fmt.Sprintf("%s    %s\n", indent, line)
			}
		}

		// Recursively write children
		if len(symbol.Children) > 0 {
			temp, err := writeSymbols(symbol.Children, depth+1)
			if err != nil {
				return "", err
			}
			output += temp
		}
	}
	return output, nil
}

func dumpFiles(paths []PathInfo, skipBinary bool) (string, error) {
	var sb strings.Builder
	sb.WriteString("## File Contents\n")

	for _, path := range paths {
		if path.IsDir {
			continue
		}

		if skipBinary {
			// Check if file is binary
			isBinary, err := IsBinaryFile(path.Path)
			if err != nil {
				return "", fmt.Errorf("checking if file %q is binary: %w", path.Path, err)
			}

			if isBinary {
				sb.WriteString(
					fmt.Sprintf("\n\n--- File: %s\n<binary file>", path.RelativePath),
				)
				continue
			}
		}

		// Read and write file content
		fileContent, err := os.ReadFile(path.Path)
		if err != nil {
			return "", fmt.Errorf("reading file %q: %w", path.Path, err)
		}

		sb.WriteString(
			fmt.Sprintf("\n--- Start File: %s\n%s\n--- End File: %s\n",
				path.RelativePath, string(fileContent), path.RelativePath),
		)
	}
	return sb.String(), nil
}

--- End File: amalgo/internal/output.go

--- Start File: amalgo/internal/output_json.go
package internal

import (
	"encoding/json"
	"fmt"
	"os"

	"github.com/Broderick-Westrope/amalgo/internal/parser"
)

type JSONDocument struct {
	Timestamp string            `json:"timestamp"`
	Tree      string            `json:"tree,omitempty"`
	Files     []JSONFile        `json:"files,omitempty"`
	Outlines  []JSONFileOutline `json:"outlines,omitempty"`
}

type JSONFile struct {
	Path    string `json:"path"`
	Content string `json:"content,omitempty"`
	Binary  bool   `json:"binary,omitempty"`
}

// JSONFileOutline represents the parsed structure of a source file
type JSONFileOutline struct {
	Path    string       `json:"path"`
	Symbols []JSONSymbol `json:"symbols,omitempty"`
	Errors  []string     `json:"errors,omitempty"`
}

// JSONSymbol represents a parsed symbol (function, type, class, etc.)
type JSONSymbol struct {
	Type          string       `json:"type"`                    // e.g., "function", "class", "interface"
	Name          string       `json:"name"`                    // Name of the symbol
	Signature     string       `json:"signature,omitempty"`     // Full signature for functions/methods
	Documentation string       `json:"documentation,omitempty"` // Associated documentation
	Decorators    []string     `json:"decorators,omitempty"`    // Any decorators/annotations
	Children      []JSONSymbol `json:"children,omitempty"`      // Nested symbols (e.g., methods in a class)
	Metadata      any          `json:"metadata,omitempty"`      // Additional language-specific metadata
}

func generateOutputJSON(paths []PathInfo, registry *parser.Registry, opts OutputOptions) (string, error) {
	doc := JSONDocument{
		Timestamp: FormatTimestamp(),
	}

	if !opts.NoTree {
		doc.Tree = GenerateTree(paths)
	}

	if !opts.NoDump {
		files, err := generateFilesJSON(paths, opts.SkipBinary)
		if err != nil {
			return "", fmt.Errorf("dumping files: %w", err)
		}
		doc.Files = files
	}

	if opts.Outline {
		outlines, err := generateOutlinesJSON(paths, registry)
		if err != nil {
			return "", fmt.Errorf("generating outlines: %w", err)
		}
		doc.Outlines = outlines
	}

	output, err := json.MarshalIndent(doc, "", "  ")
	if err != nil {
		return "", fmt.Errorf("marshaling JSON: %w", err)
	}

	return string(output) + "\n", nil
}

func generateFilesJSON(paths []PathInfo, skipBinary bool) ([]JSONFile, error) {
	files := make([]JSONFile, 0, len(paths))

	for _, path := range paths {
		if path.IsDir {
			continue
		}

		if skipBinary {
			isBinary, err := IsBinaryFile(path.Path)
			if err != nil {
				return nil, fmt.Errorf("checking if binary: %w", err)
			}

			if isBinary {
				files = append(files, JSONFile{
					Path:   path.RelativePath,
					Binary: true,
				})
				continue
			}
		}

		content, err := os.ReadFile(path.Path)
		if err != nil {
			return nil, fmt.Errorf("reading file %s: %w", path.Path, err)
		}

		files = append(files, JSONFile{
			Path:    path.RelativePath,
			Content: string(content),
		})
	}

	return files, nil
}

func generateOutlinesJSON(paths []PathInfo, registry *parser.Registry) ([]JSONFileOutline, error) {
	outlines := make([]JSONFileOutline, 0)

	for _, path := range paths {
		if path.IsDir || !registry.IsSupported(path.Path) {
			continue
		}

		content, err := os.ReadFile(path.Path)
		if err != nil {
			return nil, fmt.Errorf("reading file %s: %w", path.Path, err)
		}

		parser := registry.GetParser(path.Path)
		parsedOutline, err := parser.Parse(content, path.Path)
		if err != nil {
			return nil, fmt.Errorf("parsing file %s: %w", path.Path, err)
		}

		outline := JSONFileOutline{
			Path:    path.RelativePath,
			Symbols: make([]JSONSymbol, 0, len(parsedOutline.Symbols)),
		}

		// Convert parser.Symbols to our JSON Symbol type
		for _, sym := range parsedOutline.Symbols {
			symbol, err := convertSymbol(sym)
			if err != nil {
				return nil, fmt.Errorf("converting symbol in %s: %w", path.Path, err)
			}
			outline.Symbols = append(outline.Symbols, symbol)
		}

		// Add any parsing errors
		if len(parsedOutline.Errors) > 0 {
			outline.Errors = make([]string, len(parsedOutline.Errors))
			for i, err := range parsedOutline.Errors {
				outline.Errors[i] = err.Error()
			}
		}

		outlines = append(outlines, outline)
	}

	return outlines, nil
}

func convertSymbol(ps *parser.Symbol) (JSONSymbol, error) {
	children := make([]JSONSymbol, 0, len(ps.Children))
	for _, child := range ps.Children {
		converted, err := convertSymbol(child)
		if err != nil {
			return JSONSymbol{}, fmt.Errorf("converting child symbol: %w", err)
		}
		children = append(children, converted)
	}

	return JSONSymbol{
		Type:          ps.Type,
		Name:          ps.Name,
		Signature:     ps.Signature,
		Documentation: ps.Docstring,
		Decorators:    ps.Decorators,
		Children:      children,
		Metadata:      ps.Metadata,
	}, nil
}

--- End File: amalgo/internal/output_json.go

--- Start File: amalgo/internal/parser/golang.go
package parser

import (
	"go/ast"
	"go/parser"
	"go/token"
	"strings"
)

// GoParser implements Parser for Go source files
type GoParser struct{}

// NewGoParser creates a new Go parser
func NewGoParser() *GoParser {
	return &GoParser{}
}

func (p *GoParser) Extensions() []string {
	return []string{".go"}
}

func (p *GoParser) Parse(content []byte, filename string) (*FileOutline, error) {
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, filename, content, parser.ParseComments)
	if err != nil {
		return &FileOutline{
			Filename: filename,
			Errors:   []error{err},
		}, nil
	}

	outline := &FileOutline{
		Filename: filename,
		Symbols:  make([]*Symbol, 0),
	}

	// Process package-level declarations
	for _, decl := range file.Decls {
		symbols := p.processDecl(decl, file)
		outline.Symbols = append(outline.Symbols, symbols...)
	}

	return outline, nil
}

func (p *GoParser) processDecl(decl ast.Decl, file *ast.File) []*Symbol {
	var symbols []*Symbol

	switch d := decl.(type) {
	case *ast.FuncDecl:
		symbol := &Symbol{
			Type:      "function",
			Name:      d.Name.Name,
			Signature: p.getFunctionSignature(d),
			Docstring: p.getDocstring(d.Doc),
		}

		// Handle methods
		if d.Recv != nil {
			symbol.Type = "method"
			if len(d.Recv.List) > 0 {
				recvType := p.typeToString(d.Recv.List[0].Type)
				symbol.Name = recvType + "." + d.Name.Name
			}
		}

		symbols = append(symbols, symbol)

	case *ast.GenDecl:
		switch d.Tok {
		case token.TYPE:
			for _, spec := range d.Specs {
				if typeSpec, ok := spec.(*ast.TypeSpec); ok {
					symbol := &Symbol{
						Type:      p.getTypeSymbolType(typeSpec),
						Name:      typeSpec.Name.Name,
						Docstring: p.getDocstring(d.Doc),
					}

					// Handle interface methods and struct fields
					if symbol.Type == "interface" {
						if iface, ok := typeSpec.Type.(*ast.InterfaceType); ok {
							symbol.Children = p.processInterface(iface)
						}
					} else if symbol.Type == "struct" {
						if structType, ok := typeSpec.Type.(*ast.StructType); ok {
							symbol.Children = p.processStruct(structType)
						}
					}

					symbols = append(symbols, symbol)
				}
			}

		case token.CONST, token.VAR:
			for _, spec := range d.Specs {
				if valSpec, ok := spec.(*ast.ValueSpec); ok {
					for _, name := range valSpec.Names {
						symbol := &Symbol{
							Type:      strings.ToLower(d.Tok.String()),
							Name:      name.Name,
							Docstring: p.getDocstring(d.Doc),
						}
						if valSpec.Type != nil {
							symbol.Signature = p.typeToString(valSpec.Type)
						}
						symbols = append(symbols, symbol)
					}
				}
			}
		}
	}

	return symbols
}

func (p *GoParser) processInterface(iface *ast.InterfaceType) []*Symbol {
	var methods []*Symbol
	if iface.Methods == nil {
		return methods
	}

	for _, method := range iface.Methods.List {
		if len(method.Names) == 0 {
			continue // Skip embedded interfaces
		}

		methodType, ok := method.Type.(*ast.FuncType)
		if !ok {
			continue
		}

		for _, name := range method.Names {
			symbol := &Symbol{
				Type:      "method",
				Name:      name.Name,
				Signature: p.getFuncTypeSignature(methodType),
				Docstring: p.getDocstring(method.Doc),
			}
			methods = append(methods, symbol)
		}
	}

	return methods
}

func (p *GoParser) processStruct(structType *ast.StructType) []*Symbol {
	var fields []*Symbol
	if structType.Fields == nil {
		return fields
	}

	for _, field := range structType.Fields.List {
		if len(field.Names) == 0 {
			// Anonymous/embedded field
			symbol := &Symbol{
				Type:      "field",
				Name:      p.typeToString(field.Type),
				Signature: p.typeToString(field.Type),
				Docstring: p.getDocstring(field.Doc),
			}
			fields = append(fields, symbol)
			continue
		}

		for _, name := range field.Names {
			symbol := &Symbol{
				Type:      "field",
				Name:      name.Name,
				Signature: p.typeToString(field.Type),
				Docstring: p.getDocstring(field.Doc),
			}
			fields = append(fields, symbol)
		}
	}

	return fields
}

func (p *GoParser) getFunctionSignature(fn *ast.FuncDecl) string {
	var builder strings.Builder
	builder.WriteString("func ")

	// Add receiver if it's a method
	if fn.Recv != nil && len(fn.Recv.List) > 0 {
		builder.WriteString("(")
		if len(fn.Recv.List[0].Names) > 0 {
			builder.WriteString(fn.Recv.List[0].Names[0].Name)
			builder.WriteString(" ")
		}
		builder.WriteString(p.typeToString(fn.Recv.List[0].Type))
		builder.WriteString(") ")
	}

	builder.WriteString(fn.Name.Name)
	builder.WriteString(p.getFuncTypeSignature(fn.Type))
	return builder.String()
}

func (p *GoParser) getFuncTypeSignature(ft *ast.FuncType) string {
	var builder strings.Builder
	builder.WriteString("(")

	if ft.Params != nil {
		for i, param := range ft.Params.List {
			if i > 0 {
				builder.WriteString(", ")
			}
			for j, name := range param.Names {
				if j > 0 {
					builder.WriteString(", ")
				}
				builder.WriteString(name.Name)
			}
			if len(param.Names) > 0 {
				builder.WriteString(" ")
			}
			builder.WriteString(p.typeToString(param.Type))
		}
	}

	builder.WriteString(")")

	if ft.Results != nil {
		if ft.Results.NumFields() == 1 && len(ft.Results.List[0].Names) == 0 {
			builder.WriteString(" ")
			builder.WriteString(p.typeToString(ft.Results.List[0].Type))
		} else {
			builder.WriteString(" (")
			for i, result := range ft.Results.List {
				if i > 0 {
					builder.WriteString(", ")
				}
				for j, name := range result.Names {
					if j > 0 {
						builder.WriteString(", ")
					}
					builder.WriteString(name.Name)
				}
				if len(result.Names) > 0 {
					builder.WriteString(" ")
				}
				builder.WriteString(p.typeToString(result.Type))
			}
			builder.WriteString(")")
		}
	}

	return builder.String()
}

func (p *GoParser) typeToString(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return p.typeToString(t.X) + "." + t.Sel.Name
	case *ast.StarExpr:
		return "*" + p.typeToString(t.X)
	case *ast.ArrayType:
		return "[]" + p.typeToString(t.Elt)
	case *ast.MapType:
		return "map[" + p.typeToString(t.Key) + "]" + p.typeToString(t.Value)
	case *ast.InterfaceType:
		return "interface{}"
	case *ast.ChanType:
		switch t.Dir {
		case ast.SEND:
			return "chan<- " + p.typeToString(t.Value)
		case ast.RECV:
			return "<-chan " + p.typeToString(t.Value)
		default:
			return "chan " + p.typeToString(t.Value)
		}
	case *ast.FuncType:
		return "func" + p.getFuncTypeSignature(t)
	case *ast.StructType:
		return "struct{...}"
	case *ast.Ellipsis:
		return "..." + p.typeToString(t.Elt)
	default:
		return "<unknown>"
	}
}

func (p *GoParser) getTypeSymbolType(typeSpec *ast.TypeSpec) string {
	switch typeSpec.Type.(type) {
	case *ast.InterfaceType:
		return "interface"
	case *ast.StructType:
		return "struct"
	default:
		return "type"
	}
}

func (p *GoParser) getDocstring(doc *ast.CommentGroup) string {
	if doc == nil {
		return ""
	}
	return doc.Text()
}

--- End File: amalgo/internal/parser/golang.go

--- Start File: amalgo/internal/parser/parser.go
// Package parser provides language-specific parsing capabilities
package parser

import "path/filepath"

// Parser defines the interface for language-specific parsers
type Parser interface {
	// Parse analyzes the content of a file and returns a structured outline
	Parse(content []byte, filename string) (*FileOutline, error)

	// Extensions returns the file extensions this parser handles
	Extensions() []string
}

// Symbol represents a parsed symbol (function, type, class, etc.)
type Symbol struct {
	Type       string         // e.g., "function", "class", "interface", etc.
	Name       string         // Name of the symbol
	Signature  string         // Full signature for functions/methods
	Docstring  string         // Associated documentation
	Decorators []string       // Any decorators/annotations
	Children   []*Symbol      // Nested symbols (e.g., methods in a class)
	Metadata   map[string]any // Additional language-specific metadata
}

// FileOutline represents the parsed structure of a source file
type FileOutline struct {
	Filename string    // Name of the parsed file
	Symbols  []*Symbol // Top-level symbols in the file
	Errors   []error   // Any errors encountered during parsing
}

// Registry manages the available parsers
type Registry struct {
	parsers map[string]Parser
}

// NewRegistry creates a new parser registry
func NewRegistry() *Registry {
	return &Registry{
		parsers: make(map[string]Parser),
	}
}

// Register adds a parser to the registry
func (r *Registry) Register(parser Parser) {
	for _, ext := range parser.Extensions() {
		r.parsers[ext] = parser
	}
}

// GetParser returns the appropriate parser for a file extension
func (r *Registry) GetParser(filename string) Parser {
	ext := filepath.Ext(filename)
	return r.parsers[ext]
}

// IsSupported checks if there's a parser available for the given file extension
func (r *Registry) IsSupported(filename string) bool {
	ext := filepath.Ext(filename)
	_, ok := r.parsers[ext]
	return ok
}

--- End File: amalgo/internal/parser/parser.go

--- Start File: amalgo/internal/traverse.go
package internal

import (
	"errors"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"strings"

	"github.com/Broderick-Westrope/amalgo/pkg/filter"
)

// PathInfo represents information about a file or directory
type PathInfo struct {
	Path         string
	RelativePath string
	Depth        int
	IsDir        bool
}

// TraverseDirectory traverses the directory and collects path information using the filter package
func TraverseDirectory(dir string, filterPatterns []string) ([]PathInfo, error) {
	// Create the filterer from patterns
	f := filter.CompileFilterPatterns(filterPatterns...)

	paths := make([]PathInfo, 0)
	basePath, err := filepath.Abs(dir)
	if err != nil {
		return nil, fmt.Errorf("getting base path for directory %q: %w", dir, err)
	}

	baseInfo, err := os.Stat(basePath)
	if err != nil {
		return nil, fmt.Errorf("describing base path for directory %q: %w", dir, err)
	}

	if !baseInfo.IsDir() {
		basePath = filepath.Dir(basePath)
		baseInfo, err = os.Stat(basePath)
		if err != nil {
			return nil, err
		}
		if !baseInfo.IsDir() {
			return nil, fmt.Errorf("expected base path %q to be a directory", basePath)
		}
	}

	// Base parent allows getting the relative path in relation to the parent.
	baseParent := filepath.Dir(basePath)

	err = filepath.WalkDir(basePath, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return fmt.Errorf("at path %q: %w", path, err)
		}

		// Skip directories as the filter system is built to process file paths.
		// Skip the base path as it's already processed.
		if d.IsDir() || path == basePath {
			return nil
		}

		relPath, err := filepath.Rel(basePath, path)
		if err != nil {
			return fmt.Errorf("getting relative path between %q and %q: %w", basePath, path, err)
		}

		// Convert to forward slashes for consistent pattern matching
		relPath = filepath.ToSlash(relPath)

		// Check if a file path should be included based on patterns
		if f.MatchesPath(relPath) {
			relPath, err = filepath.Rel(baseParent, path)
			if err != nil {
				return fmt.Errorf("getting relative path between %q and %q: %w", baseParent, path, err)
			}

			paths = append(paths, PathInfo{
				Path:         path,
				RelativePath: relPath,
				Depth:        strings.Count(relPath, "/") + 1,
				IsDir:        false,
			})
		}
		return nil
	})
	if err != nil {
		return nil, fmt.Errorf("walking directory %q: %w", basePath, err)
	}

	err = processPaths(&paths)
	if err != nil {
		return nil, err
	}
	return paths, nil
}

// ProcessPaths adds all parent directory paths to the given slice of PathInfo.
// The function modifies the input slice in place, adding parent directories in order
// from shallowest to deepest, followed by the original paths.
func processPaths(paths *[]PathInfo) error {
	if paths == nil {
		return errors.New("paths must be a pointer to a slice")
	} else if *paths == nil {
		return errors.New("underlying paths slice cannot be nil")
	}

	// Create a map to deduplicate paths.
	seen := make(map[string]struct{})
	for _, path := range *paths {
		seen[path.Path] = struct{}{}
	}

	result := make([]PathInfo, len(*paths))
	if copy(result, *paths) != len(*paths) {
		return errors.New("failed to copy paths to result slice")
	}

	for _, p := range *paths {
		// Split the relative path to process each component.
		components := strings.Split(p.RelativePath, "/")
		basePath := filepath.Dir(p.Path[:len(p.Path)-len(p.RelativePath)])

		// Process each level of the path.
		currentRel := ""
		currentAbs := basePath
		for i, comp := range components {
			if i == len(components)-1 && !p.IsDir {
				// Skip the last component if it's a file - we'll add it from the original slice.
				continue
			}

			if currentRel == "" {
				currentRel = comp
			} else {
				currentRel = filepath.Join(currentRel, comp)
			}
			currentAbs = filepath.Join(currentAbs, comp)

			// Only add if we haven't seen this path before.
			if _, exists := seen[currentAbs]; !exists {
				seen[currentAbs] = struct{}{}
				result = append(result, PathInfo{
					Path:         currentAbs,
					RelativePath: currentRel,
					Depth:        i + 1,
					IsDir:        true,
				})
			}
		}
	}

	// Update the input slice with the result.
	*paths = result
	return nil
}

--- End File: amalgo/internal/traverse.go

--- Start File: amalgo/internal/traverse_test.go
package internal

import (
	"errors"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestTraverseDirectories(t *testing.T) {
	// Create a temporary directory structure for testing.
	tmpDir := t.TempDir()

	// Create test directory structure. Bool indicates if it's a directory.
	testFiles := map[string]bool{
		"src":                   true,
		"src/main.go":           false,
		"src/README.md":         false,
		"src/internal":          true,
		"src/internal/util.go":  false,
		"src/internal/test.txt": false,
		"vendor":                true,
		"vendor/lib.go":         false,
	}

	// Create the test files and directories.
	for path, isDir := range testFiles {
		fullPath := filepath.Join(tmpDir, path)
		if isDir {
			require.NoError(t, os.MkdirAll(fullPath, 0755))
		} else {
			require.NoError(t, os.MkdirAll(filepath.Dir(fullPath), 0755))
			require.NoError(t, os.WriteFile(fullPath, []byte("test content"), 0644))
		}
	}

	tests := map[string]struct {
		directory      string
		filterPatterns []string
		wantRelPaths   []string
		wantErr        bool
	}{
		"match go files in top directory": {
			directory:      filepath.Join(tmpDir, "src"),
			filterPatterns: []string{"*.go"},
			wantRelPaths: []string{
				"src/main.go",
			},
		},
		"match all go files": {
			directory:      filepath.Join(tmpDir, "src"),
			filterPatterns: []string{"**/*.go"},
			wantRelPaths: []string{
				"src/main.go",
				"src/internal/util.go",
			},
		},
		"exclude directory": {
			directory:      filepath.Join(tmpDir, "src"),
			filterPatterns: []string{"*.go", "**/*.go", "!internal/**"},
			wantRelPaths: []string{
				"src/main.go",
			},
		},
		"match specific directory": {
			directory:      filepath.Join(tmpDir, "src", "internal"),
			filterPatterns: []string{"*"},
			wantRelPaths: []string{
				"internal/util.go",
				"internal/test.txt",
			},
		},
		"non-existent directory": {
			directory:      filepath.Join(tmpDir, "nonexistent"),
			filterPatterns: []string{"**/*.go"},
			wantErr:        true,
		},
		"file as directory": {
			directory:      filepath.Join(tmpDir, "src", "main.go"),
			filterPatterns: []string{"*.go"},
			wantRelPaths: []string{
				"src/main.go",
			},
		},
	}

	for name, tt := range tests {
		t.Run(name, func(t *testing.T) {
			paths, err := TraverseDirectory(tt.directory, tt.filterPatterns)

			if tt.wantErr {
				require.Error(t, err)
				return
			}

			require.NoError(t, err)

			// Convert PathInfo slice to relative paths for easier comparison.
			var gotPaths []string
			for _, p := range paths {
				if !p.IsDir { // Only include files in our comparison
					gotPaths = append(gotPaths, p.RelativePath)
				}
			}
			assert.ElementsMatch(t, tt.wantRelPaths, gotPaths)

			// Additional validation of PathInfo fields.
			for _, p := range paths {
				// Paths should be absolute.
				assert.True(t, filepath.IsAbs(p.Path), "Path should be absolute: %s", p.Path)

				// RelativePath should not be absolute.
				assert.False(t, filepath.IsAbs(p.RelativePath), "RelativePath should be relative: %s", p.RelativePath)

				// Depth should match the number of path separators plus one.
				expectedDepth := 0
				if p.RelativePath != "" {
					expectedDepth = len(strings.Split(p.RelativePath, "/"))
				}
				assert.Equal(t, expectedDepth, p.Depth, "Incorrect depth for path: %s", p.RelativePath)
			}
		})
	}
}

func TestProcessPaths(t *testing.T) {
	var nilPathInfoSlice []PathInfo = nil
	tests := map[string]struct {
		paths     *[]PathInfo
		wantPaths []PathInfo
		wantErr   error
	}{
		"single file adds parent dirs": {
			paths: &[]PathInfo{
				{
					Path:         "/Users/someuser/dev/program/internal/file1.go",
					RelativePath: "program/internal/file1.go",
					Depth:        3,
					IsDir:        false,
				},
			},
			wantPaths: []PathInfo{
				{
					Path:         "/Users/someuser/dev/program/internal/file1.go",
					RelativePath: "program/internal/file1.go",
					Depth:        3,
					IsDir:        false,
				},
				{
					Path:         "/Users/someuser/dev/program",
					RelativePath: "program",
					Depth:        1,
					IsDir:        true,
				},
				{
					Path:         "/Users/someuser/dev/program/internal",
					RelativePath: "program/internal",
					Depth:        2,
					IsDir:        true,
				},
			},
		},
		"multiple files same directory": {
			paths: &[]PathInfo{
				{
					Path:         "/Users/someuser/dev/program/internal/file1.go",
					RelativePath: "program/internal/file1.go",
					Depth:        3,
					IsDir:        false,
				},
				{
					Path:         "/Users/someuser/dev/program/internal/file2.go",
					RelativePath: "program/internal/file2.go",
					Depth:        3,
					IsDir:        false,
				},
			},
			wantPaths: []PathInfo{
				{
					Path:         "/Users/someuser/dev/program/internal/file1.go",
					RelativePath: "program/internal/file1.go",
					Depth:        3,
					IsDir:        false,
				},
				{
					Path:         "/Users/someuser/dev/program/internal/file2.go",
					RelativePath: "program/internal/file2.go",
					Depth:        3,
					IsDir:        false,
				},
				{
					Path:         "/Users/someuser/dev/program",
					RelativePath: "program",
					Depth:        1,
					IsDir:        true,
				},
				{
					Path:         "/Users/someuser/dev/program/internal",
					RelativePath: "program/internal",
					Depth:        2,
					IsDir:        true,
				},
			},
		},
		"different directory depths": {
			paths: &[]PathInfo{
				{
					Path:         "/Users/someuser/dev/program/file1.go",
					RelativePath: "program/file1.go",
					Depth:        2,
					IsDir:        false,
				},
				{
					Path:         "/Users/someuser/dev/program/internal/deep/file2.go",
					RelativePath: "program/internal/deep/file2.go",
					Depth:        4,
					IsDir:        false,
				},
			},
			wantPaths: []PathInfo{
				{
					Path:         "/Users/someuser/dev/program/file1.go",
					RelativePath: "program/file1.go",
					Depth:        2,
					IsDir:        false,
				},
				{
					Path:         "/Users/someuser/dev/program/internal/deep/file2.go",
					RelativePath: "program/internal/deep/file2.go",
					Depth:        4,
					IsDir:        false,
				},
				{
					Path:         "/Users/someuser/dev/program",
					RelativePath: "program",
					Depth:        1,
					IsDir:        true,
				},
				{
					Path:         "/Users/someuser/dev/program/internal",
					RelativePath: "program/internal",
					Depth:        2,
					IsDir:        true,
				},
				{
					Path:         "/Users/someuser/dev/program/internal/deep",
					RelativePath: "program/internal/deep",
					Depth:        3,
					IsDir:        true,
				},
			},
		},
		"directory included": {
			paths: &[]PathInfo{
				{
					Path:         "/Users/someuser/dev/program/internal",
					RelativePath: "program/internal",
					Depth:        2,
					IsDir:        true,
				},
				{
					Path:         "/Users/someuser/dev/program/internal/file1.go",
					RelativePath: "program/internal/file1.go",
					Depth:        3,
					IsDir:        false,
				},
			},
			wantPaths: []PathInfo{
				{
					Path:         "/Users/someuser/dev/program/internal",
					RelativePath: "program/internal",
					Depth:        2,
					IsDir:        true,
				},
				{
					Path:         "/Users/someuser/dev/program/internal/file1.go",
					RelativePath: "program/internal/file1.go",
					Depth:        3,
					IsDir:        false,
				},
				{
					Path:         "/Users/someuser/dev/program",
					RelativePath: "program",
					Depth:        1,
					IsDir:        true,
				},
			},
		},
		"empty slice": {
			paths:     &[]PathInfo{},
			wantPaths: []PathInfo{},
		},
		"nil slice": {
			paths:     &nilPathInfoSlice,
			wantPaths: []PathInfo{},
			wantErr:   errors.New("underlying paths slice cannot be nil"),
		},
		"nil pointer": {
			paths:     nil,
			wantPaths: []PathInfo{},
			wantErr:   errors.New("paths must be a pointer to a slice"),
		},
	}

	for name, tt := range tests {
		t.Run(name, func(t *testing.T) {
			err := processPaths(tt.paths)
			if tt.wantErr != nil {
				assert.EqualError(t, err, tt.wantErr.Error())
				return
			}
			require.NoError(t, err)

			assert.Equal(t, tt.wantPaths, *tt.paths)
		})
	}
}

--- End File: amalgo/internal/traverse_test.go

--- Start File: amalgo/internal/utils.go
package internal

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"time"
)

// IsBinaryFile determines if a file is binary by checking its contents
func IsBinaryFile(path string) (bool, error) {
	file, err := os.Open(path)
	if err != nil {
		return false, fmt.Errorf("opening file: %w", err)
	}
	defer file.Close()

	// Read first 512 bytes
	buf := make([]byte, 512)
	n, err := file.Read(buf)
	if err != nil && err != io.EOF {
		return false, fmt.Errorf("reading file: %w", err)
	}
	buf = buf[:n]

	// Check for null bytes
	if bytes.IndexByte(buf, 0) != -1 {
		return true, nil
	}

	// Look for non-text characters
	for _, b := range buf {
		if b < 32 && b != 9 && b != 10 && b != 13 { // Not tab, LF, or CR
			return true, nil
		}
	}
	return false, nil
}

// GenerateTree creates a textual representation of the directory structure
func GenerateTree(paths []PathInfo) string {
	if len(paths) == 0 {
		return "< no paths found >\n"
	}

	mapPathToChildren := make(map[string][]PathInfo)
	for _, path := range paths {
		if path.Depth == 0 {
			continue
		}
		parent := filepath.Dir(path.Path)
		mapPathToChildren[parent] = append(mapPathToChildren[parent], path)
	}

	var output string
	var printTree func(path PathInfo, prefix string, isLast bool)
	printTree = func(path PathInfo, prefix string, isLast bool) {
		// Print current item
		connector := "├── "
		if isLast {
			connector = "└── "
		}

		name := filepath.Base(path.Path)
		if path.IsDir {
			name += "/"
		}
		output += fmt.Sprintf("%s%s%s\n", prefix, connector, name)

		// Print children
		childPrefix := prefix + "│   "
		if isLast {
			childPrefix = prefix + "    "
		}

		pathChildren := mapPathToChildren[path.Path]
		for i, child := range pathChildren {
			printTree(child, childPrefix, i == len(pathChildren)-1)
		}
	}

	shortestPath := paths[0]
	for _, path := range paths {
		if len(path.Path) < len(shortestPath.Path) {
			shortestPath = path
		}
	}

	// Find and process root level items.
	rootPaths := mapPathToChildren[filepath.Dir(shortestPath.Path)]
	for i, path := range rootPaths {
		printTree(path, "", i == len(rootPaths)-1)
	}
	return output
}

// WriteOutput writes content to a file or stdout
func WriteOutput(path string, content string) error {
	if path == "stdout" || path == "-" {
		_, err := fmt.Print(content)
		return fmt.Errorf("writing to stdout: %w", err)
	}

	dir := filepath.Dir(path)
	err := os.MkdirAll(dir, 0755)
	if err != nil {
		return fmt.Errorf("creating directories along path %q: %w", dir, err)
	}

	err = os.WriteFile(path, []byte(content), 0644)
	if err != nil {
		return fmt.Errorf("writing to file: %w", err)
	}
	return nil
}

// FormatTimestamp returns a formatted timestamp string
func FormatTimestamp() string {
	return time.Now().Format("2006-01-02 15:04:05")
}

--- End File: amalgo/internal/utils.go

--- Start File: amalgo/main.go
package main

import (
	"fmt"
	"os"
	"strings"

	"github.com/Broderick-Westrope/amalgo/internal"
	"github.com/Broderick-Westrope/amalgo/internal/parser"
	"github.com/alecthomas/kong"
	"github.com/fatih/color"
)

const (
	appName = "amalgo"
	version = "0.4.0"
)

func main() {
	os.Exit(run())
}

func run() int {
	cli := RootCmd{
		Version: versionFlag(version),
	}

	exitHandler := &exitWriter{}
	ctx := kong.Parse(&cli,
		kong.Name(appName),
		kong.Description("Create consolidated snapshots of source code for analysis, documentation, and sharing with LLMs."),
		kong.UsageOnError(),
		kong.Writers(os.Stdout, exitHandler),
		kong.Exit(exitHandler.Exit),
		kong.DefaultEnvars(appName),
		kong.Vars{"version": string(cli.Version)},
	)

	if exitHandler.code != 0 {
		fmt.Fprintf(os.Stderr, "%s", exitHandler.message)
		return exitHandler.code
	}

	err := ctx.Run()
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		return 1
	}
	return 0
}

type RootCmd struct {
	// Default command args and flags
	Dir           string                `arg:"" optional:"" help:"Directory to analyze. If a file is provided it's parent directory will be used." type:"path" default:"."`
	Output        string                `help:"Specifies the destination path for the output file. The file extension will automatically adjust based on the selected format (see '--format')." short:"o" type:"path" placeholder:"amalgo.txt"`
	Stdout        bool                  `help:"Redirects all output to standard output (terminal) instead of writing to a file. Useful for piping output to other commands."`
	Filter        []string              `help:"Controls which files are processed using glob patterns. Include patterns are processed first, then exclude patterns (prefixed with '!'). Hidden files and directories are excluded by default." short:"f" default:"*,!.*"`
	NoTree        bool                  `help:"Skips the inclusion of the file tree in the output." default:"false"`
	NoDump        bool                  `help:"Skips the inclusion of file contents in the output." default:"false"`
	Outline       bool                  `help:"Includes in the output a language-aware outline of code files, showing functions, classes, and other significant elements. Only available for specific file extensions: '.go'." default:"false"`
	NoColor       bool                  `help:"Disables ANSI color codes in the output." default:"false"`
	IncludeBinary bool                  `help:"Processes binary files instead of skipping them. Use with caution as this may produce large or unreadable output." default:"false"`
	Format        internal.OutputFormat `help:"Selects an alternative output format. This affects both the structure and the file extension of the output. Options: 'default', 'json'." enum:"default,json" default:"default"`

	// Subcommands
	Version versionFlag `help:"Displays the current version of the tool and exits immediately." short:"v" name:"version"`
}

func (c *RootCmd) validate() bool {
	if c.Output == "" {
		if c.Format == internal.OutputFormatJSON {
			c.Output += "amalgo.json"
		} else {
			c.Output = "amalgo.txt"
		}
	}

	issues := make([]string, 0)
	if c.NoDump && c.NoTree && !c.Outline {
		issues = append(issues, "An empty output is not allowed (no dump, no tree, and no outline).")
	}

	if len(issues) == 0 {
		return true
	}
	out := strings.Join(issues, "\n")
	if !c.NoColor {
		out = color.RedString(out)
	}
	fmt.Println(out)
	return false
}

func (c *RootCmd) Run() error {
	if !c.validate() {
		return nil
	}

	outputDest := c.Output
	if c.Stdout {
		outputDest = "stdout"
	}

	registry := parser.NewRegistry()
	registry.Register(parser.NewGoParser())

	paths, err := internal.TraverseDirectory(c.Dir, c.Filter)
	if err != nil {
		return fmt.Errorf("traversing directories: %w", err)
	}

	outputOpts := internal.OutputOptions{
		NoTree:     c.NoTree,
		NoDump:     c.NoDump,
		Outline:    c.Outline,
		SkipBinary: !c.IncludeBinary,
		Format:     c.Format,
	}

	output, err := internal.GenerateOutput(paths, registry, outputOpts)
	if err != nil {
		return fmt.Errorf("generating output: %w", err)
	}

	err = internal.WriteOutput(outputDest, output)
	if err != nil {
		return fmt.Errorf("writing output: %w", err)
	}

	// Print success message unless output is stdout.
	if outputDest != "stdout" {
		msg := fmt.Sprintf("Successfully generated output to: %s\n", outputDest)
		if !c.NoColor {
			msg = color.GreenString(msg)
		}
		fmt.Print(msg)
	}

	return nil
}

type versionFlag string

func (v versionFlag) Decode(_ *kong.DecodeContext) error { return nil }
func (v versionFlag) IsBool() bool                       { return true }
func (v versionFlag) BeforeApply(app *kong.Kong, vars kong.Vars) error {
	fmt.Println(vars["version"])
	app.Exit(0)
	return nil
}

// Custom writer that can capture output for testing
type exitWriter struct {
	code    int
	message string
}

func (w *exitWriter) Write(p []byte) (n int, err error) {
	w.message += string(p)
	return len(p), nil
}

func (w *exitWriter) Exit(code int) {
	w.code = code
}

--- End File: amalgo/main.go

--- Start File: amalgo/main_test.go
package main

import (
	"fmt"
	"os"
	"strings"
	"testing"

	"github.com/fatih/color"
	"github.com/rogpeppe/go-internal/testscript"
	"github.com/sergi/go-diff/diffmatchpatch"
)

func TestMain(m *testing.M) {
	color.NoColor = false
	os.Exit(testscript.RunMain(m,
		map[string]func() int{
			appName: run,
		},
	))
}

func TestScript(t *testing.T) {
	testscript.Run(t, testscript.Params{
		Dir: "testdata/script",
		Setup: func(env *testscript.Env) error {
			return nil
		},
		Cmds: map[string]func(ts *testscript.TestScript, neg bool, args []string){
			"cmpfile": compareFiles,
			"showfile": func(ts *testscript.TestScript, neg bool, args []string) {
				if len(args) != 1 {
					ts.Fatalf("usage: showfile filename")
				}
				content, err := os.ReadFile(ts.MkAbs(args[0]))
				if err != nil {
					ts.Fatalf("reading %s: %v", args[0], err)
				}
				fmt.Fprintf(ts.Stdout(), "=== Content of %s ===\n", args[0])
				fmt.Fprintf(ts.Stdout(), "%s\n", content)
				fmt.Fprintf(ts.Stdout(), "=== End of %s ===\n", args[0])
			},
		},
	})
}

func compareFiles(ts *testscript.TestScript, neg bool, args []string) {
	if len(args) != 2 {
		ts.Fatalf("usage: cmpfile actual expected")
	}
	temp := ts.MkAbs(args[0])
	actual, err := os.ReadFile(temp)
	if err != nil {
		ts.Fatalf("reading %q (actual): %v", temp, err)
	}
	temp = ts.MkAbs(args[1])
	expected, err := os.ReadFile(temp)
	if err != nil {
		ts.Fatalf("reading %q (expected): %v", temp, err)
	}

	// Split into lines
	actualLines := strings.Split(string(actual), "\n")
	expectedLines := strings.Split(string(expected), "\n")

	// Create debug versions with visible empty lines
	debugActual := make([]string, len(actualLines))
	debugExpected := make([]string, len(expectedLines))

	for i, line := range actualLines {
		if line == "" {
			debugActual[i] = "<empty>"
		} else {
			debugActual[i] = line
		}
	}

	for i, line := range expectedLines {
		if line == "" {
			debugExpected[i] = "<empty>"
		} else {
			debugExpected[i] = line
		}
	}

	matchFailed := false
	if len(actualLines) != len(expectedLines) {
		if !neg {
			matchFailed = true
		}
	}

	for i := 0; i < len(actualLines) && i < len(expectedLines); i++ {
		aLine := actualLines[i]
		eLine := expectedLines[i]
		// Skip timestamp line
		if strings.Contains(aLine, "Generated with Amalgo at:") || strings.Contains(aLine, "timestamp") {
			continue
		}
		if aLine != eLine {
			matchFailed = true
			break
		}
	}

	if matchFailed {
		diffStr := createDiff(
			fmt.Sprintf("Expected (%d lines)", len(expectedLines)),
			fmt.Sprintf("Actual (%d lines)", len(actualLines)),
			strings.Join(debugExpected, "\n"),
			strings.Join(debugActual, "\n"),
		)
		ts.Fatalf("Failed to match:\n%s", diffStr)
	} else if neg {
		ts.Fatalf("files match but should not")
	}
}

func createDiff(name1, name2, text1, text2 string) string {
	dmp := diffmatchpatch.New()
	diffs := dmp.DiffMain(text1, text2, false)
	return fmt.Sprintf(
		"%s\n%s\n%s",
		color.RedString("--- "+name1),
		color.GreenString("+++ "+name2),
		dmp.DiffPrettyText(diffs),
	)
}

--- End File: amalgo/main_test.go

--- Start File: amalgo/pkg/filter/filter.go
// Package filter provides functionality for matching paths against exclusion patterns
// using a syntax similar to gitignore - patterns indicate what to include (match against)
// unless prefixed with '!'. This can be used for both file inclusion and exclusion.
package filter

import (
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

// Filterer wraps a list of filter patterns.
type Filterer struct {
	patterns []*Pattern
}

// Pattern encapsulates a regexp pattern and whether it is negated.
type Pattern struct {
	Pattern *regexp.Regexp
	Negate  bool
	LineNo  int
	Line    string
}

// MatchesPath returns true if the path matches the patterns.
func (f *Filterer) MatchesPath(path string) bool {
	matches, _ := f.MatchesPathHow(path)
	return matches
}

// MatchesPathHow returns whether the path matches and which pattern matched it.
func (f *Filterer) MatchesPathHow(path string) (bool, *Pattern) {
	// Normalize path separators.
	path = filepath.ToSlash(path)

	var matchingPattern *Pattern
	matchesPath := false

	for _, pattern := range f.patterns {
		if pattern.Pattern.MatchString(path) {
			if !pattern.Negate {
				matchesPath = true
				matchingPattern = pattern
			} else if matchesPath {
				// Path was previously matched but now negated.
				matchesPath = false
				matchingPattern = pattern
			}
		}
	}
	return matchesPath, matchingPattern
}

// CompileFilterPatterns accepts a variadic set of strings and returns a Filterer
// instance with the compiled patterns.
func CompileFilterPatterns(patterns ...string) *Filterer {
	f := new(Filterer)
	for i, pattern := range patterns {
		pattern = strings.TrimRight(pattern, "\r")
		pattern = strings.TrimSpace(pattern)
		compiledPattern, isNegated := getPatternFromLine(pattern)
		if compiledPattern != nil {
			fp := &Pattern{compiledPattern, isNegated, i + 1, pattern}
			f.patterns = append(f.patterns, fp)
		}
	}
	return f
}

// CompileFilterPatternFile reads patterns from a file and compiles them.
func CompileFilterPatternFile(path string) (*Filterer, error) {
	bs, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	patterns := strings.Split(string(bs), "\n")
	return CompileFilterPatterns(patterns...), nil
}

// CompileExcludePatternFileAndLines compiles patterns from both a file and additional lines.
func CompileFilterPatternFileAndLines(path string, lines ...string) (*Filterer, error) {
	bs, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	patterns := append(strings.Split(string(bs), "\n"), lines...)
	return CompileFilterPatterns(patterns...), nil
}

// getPatternFromLine converts a single pattern line into a regexp and bool indicating
// if it's a negated pattern. The rules follow .gitignore syntax.
func getPatternFromLine(line string) (*regexp.Regexp, bool) {
	// Strip comments.
	if strings.HasPrefix(line, "#") {
		return nil, false
	}

	// Skip empty lines.
	if line == "" {
		return nil, false
	}

	// Check for negation prefix. Several will negate the previous negation (ie. toggling).
	negatePattern := false
	for line[0] == '!' {
		negatePattern = !negatePattern
		line = line[1:]
	}

	// Create a copy of the line to modify. The original is maintained for later checks.
	expr := line

	// Ignore a prefix of escaped '#' or '!'.
	if regexp.MustCompile(`^(\#|\!)`).MatchString(expr) {
		expr = expr[1:]
	}

	// Escape dots.
	expr = regexp.MustCompile(`\.`).ReplaceAllString(expr, `\.`)

	// This 'magic star" is used temporarily when handling other single-star cases.
	magicStar := "#$~"

	// Handle '/**/' patterns.
	if strings.HasPrefix(expr, "/**/") {
		expr = expr[1:]
	}
	expr = regexp.MustCompile(`/\*\*/`).ReplaceAllString(expr, `(/|/.+/)`)
	expr = regexp.MustCompile(`\*\*/`).ReplaceAllString(expr, `(|.`+magicStar+`/)`)
	expr = regexp.MustCompile(`/\*\*`).ReplaceAllString(expr, `(|/.`+magicStar+`)`)

	// Handle wildcards.
	expr = regexp.MustCompile(`\\\*`).ReplaceAllString(expr, `\`+magicStar)
	expr = regexp.MustCompile(`\*`).ReplaceAllString(expr, `([^/]*)`) // '*' may be any number of characters other than '/'
	expr = strings.Replace(expr, "?", `[^/]`, -1)                     // '?' may be any single character other than '/'
	expr = strings.Replace(expr, magicStar, "*", -1)

	// Build final regex.
	if strings.HasSuffix(line, "/") {
		expr += "(|.*)$"
	} else {
		expr += "(|/.*)$"
	}

	// Only add directory prefix for patterns starting with /
	switch {
	case strings.HasPrefix(line, "/"):
		expr = "^(|/)" + expr[1:]

	case strings.HasPrefix(line, "**/"):
		// Pattern contains a slash but doesn't start with one
		expr = "^(|.*/)" + expr

	default:
		// Simple pattern like *.go - should only match in current directory
		expr = "^" + expr
	}

	pattern, _ := regexp.Compile(expr)
	return pattern, negatePattern
}

--- End File: amalgo/pkg/filter/filter.go

--- Start File: amalgo/pkg/filter/filter_test.go
package filter

import (
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestMatchesPath(t *testing.T) {
	tests := map[string]struct {
		patterns []string
		path     string
		want     bool
	}{
		"double asterisk at start": {
			patterns: []string{"**/test.txt"},
			path:     "deep/nested/test.txt",
			want:     true,
		},
		"double asterisk in middle": {
			patterns: []string{"src/**/test.txt"},
			path:     "src/deeply/nested/test.txt",
			want:     true,
		},
		"double asterisk at end": {
			patterns: []string{"src/**"},
			path:     "src/any/number/of/subdirs",
			want:     true,
		},
		"leading slash": {
			patterns: []string{"/root.txt"},
			path:     "root.txt",
			want:     true,
		},
		"single character wildcard": {
			patterns: []string{"test?.txt"},
			path:     "test1.txt",
			want:     true,
		},
		"actual dots in filenames": {
			patterns: []string{"*.txt"},
			path:     "file.txt",
			want:     true,
		},
		"multiple extensions separate patterns": {
			patterns: []string{"*.txt", "*.md", "*.json"},
			path:     "file.json",
			want:     true,
		},
		"complex nesting with negation": {
			patterns: []string{
				"**/*.go",
				"!vendor/**",
				"vendor/allowed/*.go",
			},
			path: "vendor/forbidden/file.go",
			want: false,
		},
		"multiple patterns with precedence": {
			patterns: []string{
				"*.txt",
				"!important/*.txt",
				"important/keepthis.txt",
			},
			path: "important/keepthis.txt",
			want: true,
		},
		"spaces in pattern": {
			patterns: []string{" *.txt ", "  ", " # comment "},
			path:     "file.txt",
			want:     true,
		},
		"carriage return handling": {
			patterns: []string{"*.txt\r", "*.md\r"},
			path:     "file.txt",
			want:     true,
		},
		"simple match": {
			patterns: []string{"*.txt"},
			path:     "file.txt",
			want:     true,
		},
		"no match": {
			patterns: []string{"*.txt"},
			path:     "file.go",
			want:     false,
		},
		"negated pattern": {
			patterns: []string{"*.txt", "!test.txt"},
			path:     "test.txt",
			want:     false,
		},
		"directory match": {
			patterns: []string{"src/**/*.go"},
			path:     "src/pkg/file.go",
			want:     true,
		},
		"escaped characters": {
			patterns: []string{"\\#file.txt"},
			path:     "#file.txt",
			want:     true,
		},
		"multiple patterns with override": {
			patterns: []string{"*.txt", "!test.txt", "test.txt"},
			path:     "test.txt",
			want:     true,
		},
		"directory trailing slash": {
			patterns: []string{"logs/"},
			path:     "logs/debug.log",
			want:     true,
		},
		"comment and empty lines": {
			patterns: []string{"", "# comment", "*.txt"},
			path:     "file.txt",
			want:     true,
		},
	}

	for name, tc := range tests {
		t.Run(name, func(t *testing.T) {
			f := CompileFilterPatterns(tc.patterns...)
			got := f.MatchesPath(tc.path)
			assert.Equal(t, got, tc.want, "path: %q, patterns: %v", tc.path, tc.patterns)
		})
	}
}

func TestMatchesPathHow(t *testing.T) {
	tests := map[string]struct {
		patterns        []string
		path            string
		wantMatch       bool
		wantMatchLine   string
		wantMatchNegate bool
	}{
		"matches first pattern": {
			patterns:        []string{"*.txt", "*.go"},
			path:            "file.txt",
			wantMatch:       true,
			wantMatchLine:   "*.txt",
			wantMatchNegate: false,
		},
		"matches negated pattern": {
			patterns:        []string{"*.txt", "!test.txt"},
			path:            "test.txt",
			wantMatch:       false,
			wantMatchLine:   "!test.txt",
			wantMatchNegate: true,
		},
		"no match returns nil pattern": {
			patterns:        []string{"*.txt"},
			path:            "file.go",
			wantMatch:       false,
			wantMatchLine:   "",
			wantMatchNegate: false,
		},
	}

	for name, tc := range tests {
		t.Run(name, func(t *testing.T) {
			f := CompileFilterPatterns(tc.patterns...)
			gotMatch, gotPattern := f.MatchesPathHow(tc.path)

			assert.Equal(t, tc.wantMatch, gotMatch)

			if tc.wantMatchLine == "" {
				assert.Nil(t, gotPattern)
				return
			}

			assert.NotNil(t, gotPattern)
			assert.Equal(t, tc.wantMatchLine, gotPattern.Line)
			assert.Equal(t, tc.wantMatchNegate, gotPattern.Negate)
		})
	}
}

func TestCompileAndMatchPatterns(t *testing.T) {
	tests := map[string]struct {
		patterns    []string
		pathsToWant map[string]bool
	}{
		"match all files": {
			patterns: []string{"*"},
			pathsToWant: map[string]bool{
				"main.go":              true,
				"internal/util.go":     true,
				"src/main.go":          true,
				"src/internal/util.go": true,
				"README.md":            true,
				"internal/test.txt":    true,
			},
		},
		"match all files except top-level hidden files and directories": {
			patterns: []string{"*", "!.*"},
			pathsToWant: map[string]bool{
				"main.go":              true,
				"internal/util.go":     true,
				"src/main.go":          true,
				"src/internal/util.go": true,
				"src/.env":             true,
				"README.md":            true,
				"internal/test.txt":    true,

				".git/config.txt": false,
				".env":            false,
			},
		},
		"match all files except recursive hidden files and directories": {
			patterns: []string{"*", "!**/.*"},
			pathsToWant: map[string]bool{
				"main.go":              true,
				"internal/util.go":     true,
				"src/main.go":          true,
				"src/internal/util.go": true,
				"README.md":            true,
				"internal/test.txt":    true,

				"src/.env":        false,
				".git/config.txt": false,
				".env":            false,
			},
		},
		"match top-level go files": {
			patterns: []string{"*.go"},
			pathsToWant: map[string]bool{
				"main.go": true,

				"internal/util.go":     false,
				"src/main.go":          false,
				"src/internal/util.go": false,
				"README.md":            false,
				"internal/test.txt":    false,
			},
		},
		"match go files recursively": {
			patterns: []string{"**/*.go"},
			pathsToWant: map[string]bool{
				"main.go":              true,
				"internal/util.go":     true,
				"src/main.go":          true,
				"src/internal/util.go": true,

				"README.md":         false,
				"internal/test.txt": false,
			},
		},
		"match go files recursively with negation": {
			patterns: []string{"**/*.go", "!internal/**"},
			pathsToWant: map[string]bool{
				"main.go":              true,
				"src/main.go":          true,
				"src/internal/util.go": true,

				"internal/util.go":  false,
				"README.md":         false,
				"internal/test.txt": false,
			},
		},
		"match with escaped special characters": {
			patterns: []string{`\!important.txt`, `\#comment.txt`},
			pathsToWant: map[string]bool{
				"!important.txt": true,
				"#comment.txt":   true,

				"important.txt":       false,
				"comment.txt":         false,
				"test/!important.txt": false,
			},
		},
		"match directories with trailing slash": {
			patterns: []string{"docs/", "!docs/internal/"},
			pathsToWant: map[string]bool{
				"docs/readme.md":   true,
				"docs/api/spec.md": true,

				"docs/internal/dev.md":  false,
				"docs/internal/arch.md": false,
				"other/docs/readme.md":  false,
			},
		},
		"match with directory depth constraints": {
			patterns: []string{
				"/*/*.go",    // Matches files exactly one directory deep
				"!/**/test/", // Excludes any test directories at any depth
			},
			pathsToWant: map[string]bool{
				"cmd/main.go":        true,
				"internal/config.go": true,

				"main.go":              false,
				"pkg/sub/util.go":      false,
				"cmd/test/testutil.go": false,
			},
		},
		"recursively match subdirectory and extension": {
			patterns: []string{"src/**/*.go"},
			pathsToWant: map[string]bool{
				"src/pkg/file.go": true,

				"cmd/main.go":          false,
				"internal/config.go":   false,
				"main.go":              false,
				"pkg/sub/util.go":      false,
				"cmd/test/testutil.go": false,
			},
		},
		"complex nested directory matching": {
			patterns: []string{
				"src/*/test/**/*.go",
				"!src/*/test/vendor/**",
				"!src/temp/*/",
			},
			pathsToWant: map[string]bool{
				"src/project/test/unit/main_test.go":      true,
				"src/lib/test/integration/helper_test.go": true,

				"src/project/test/vendor/mock/mock.go": false,
				"src/temp/cache/data.txt":              false,
				"src/project/prod/main.go":             false,
			},
		},
		"match with multiple pattern ordering": {
			patterns: []string{
				"*.txt",
				"!important.txt",
				"!!important.txt",
				"!test/important.txt",
			},
			pathsToWant: map[string]bool{
				"readme.txt":         true,
				"important.txt":      true,
				"docs/notes.txt":     false,
				"test/important.txt": false,
			},
		},
		"match with question mark wildcards": {
			patterns: []string{"test?.txt", "lib/????.go"},
			pathsToWant: map[string]bool{
				"test1.txt":   true,
				"testa.txt":   true,
				"lib/util.go": true,
				"lib/main.go": true,

				"test.txt":     false,
				"test12.txt":   false,
				"lib/utils.go": false,
			},
		},
	}

	for name, tt := range tests {
		t.Run(name, func(t *testing.T) {
			f := CompileFilterPatterns(tt.patterns...)

			for path, want := range tt.pathsToWant {
				got := f.MatchesPath(path)
				assert.Equal(t, want, got, "Patterns: %q; Path: %q", strings.Join(tt.patterns, ", "), path)
			}
		})
	}
}

--- End File: amalgo/pkg/filter/filter_test.go

--- Start File: amalgo/testdir/file1.go
package main

func main() {}

--- End File: amalgo/testdir/file1.go

--- Start File: amalgo/testdir/sub/file2.go
package sub

func Helper() {}

--- End File: amalgo/testdir/sub/file2.go
